<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flame Walker: Mobile Edition</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(-45deg, #98273c, #bd3f5a, #c0516d, #a4314c);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            font-family: 'Arial', sans-serif;
        }
        
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes flameFlicker {
            0% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff4500, 0 0 30px #ff4500; }
            50% { text-shadow: 0 0 15px #ff8c00, 0 0 25px #ff8c00, 0 0 35px #ff8c00; }
            100% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff4500, 0 0 30px #ff4500; }
        }
        
        #gameContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            max-width: 100vmin;
            max-height: 80vmin;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background-color: #222;
            border-radius: 12px;
        }
        
        #menuOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            z-index: 10;
            color: white;
            text-align: center;
            border-radius: 12px;
        }
        
        #gameTitle {
            color: #ff4500;
            font-size: 10vmin;
            font-weight: bold;
            text-transform: uppercase;
            margin: 0;
            animation: flameFlicker 2s infinite;
            text-shadow: 0 0 10px #ff4500, 0 0 20px #ff4500;
        }
        
        #startButton, #restartButton {
            padding: 15px 30px;
            font-size: 4vmin;
            background: linear-gradient(to right, #ff4500, #ff8c00);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 15px 0;
            width: 60%;
            max-width: 200px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
            position: relative;
            overflow: hidden;
            z-index: 5;
        }
        
        #startButton:active, #restartButton:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(255, 69, 0, 0.3);
        }
        
        #highScores {
            background: rgba(255,100,30,0.2);
            padding: 15px;
            border-radius: 10px;
            width: 80%;
            max-width: 300px;
            margin-top: 5vmin;
            backdrop-filter: blur(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 69, 0, 0.3);
        }
        
        #highScores h2 {
            margin-top: 0;
            font-size: 4vmin;
        }
        
        #highScoresList {
            font-size: 3vmin;
            text-align: left;
            padding-left: 10px;
        }
        
        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            color: white;
            border-radius: 12px;
        }
        
        #gameOverlay h1 {
            font-size: 6vmin;
            margin-bottom: 1vmin;
        }
        
        #finalScore, #finalLevel {
            font-size: 4vmin;
            margin: 2vmin 0;
        }
        
        #controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 5vmin;
            box-sizing: border-box;
            z-index: 15;
            pointer-events: none;
        }
        
        #joystickContainer {
            width: 20vmin;
            height: 20vmin;
            background-color: rgba(255,255,255,0.1);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            margin-bottom: 2vmin;
        }
        
        #joystick {
            width: 8vmin;
            height: 8vmin;
            background-color: rgba(255,255,255,0.4);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #jumpBtn {
            width: 15vmin;
            height: 10vmin;
            background-color: rgba(255,255,255,0.3);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3vmin;
            color: white;
            user-select: none;
            pointer-events: auto;
            margin-bottom: 2vmin;
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
            z-index: 15;
        }
        
        .flame-container {
            position: relative;
            width: 10vmin;
            height: 10vmin;
            transform: translateY(-5vmin);
        }
        
        .flame {
            position: absolute;
            width: 6vmin;
            height: 6vmin;
            background: radial-gradient(circle, yellow, orange 50%, red);
            border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%;
            box-shadow: 0 0 10px #ff4500, 0 0 20px orange;
            animation: flame 1s infinite alternate;
        }
        
        @keyframes flame {
            0% { transform: scale(1); opacity: 0.9; }
            100% { transform: scale(1.1); opacity: 1; }
        }
        
        /* Controls panel for game overlay */
        #controlsInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 2.5vmin;
            z-index: 25;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="menuOverlay">
            <div>
                <h1 id="gameTitle">Flame Walker</h1>
                <div class="flame-container">
                    <div class="flame"></div>
                </div>
            </div>
            
            <button id="startButton">START GAME</button>
            
            <div id="highScores">
                <h2>High Scores</h2>
                <div id="highScoresList"></div>
            </div>
        </div>
        
        <div id="gameOverlay">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="finalScore">Score: 0</p>
            <p id="finalLevel">Level: 1</p>
            <button id="restartButton">RESTART</button>
        </div>

        <div id="controls">
            <div id="joystickContainer">
                <div id="joystick"></div>
            </div>
            <div id="jumpBtn">JUMP</div>
        </div>
        
        <div id="controlsInfo">
            <p>Controls:</p>
            <p>Move: Arrow Keys or A/D</p>
            <p>Jump: Up Arrow, W, or Space</p>
        </div>
    </div>

    <script>
        // Global configuration
        const DEBUG_MODE = false;
        
        function log(message) {
            if (DEBUG_MODE) {
                console.log(message);
            }
        }
        
        function showError(message) {
            console.error(message);
        }

        // Game state
        const gameState = {
            score: 0,
            lives: 3,
            currentLevel: 0,
            gameActive: false,
            highScores: [],
            keys: {
                left: false,
                right: false,
                up: false
            },
            
            updateScore(points) {
                this.score += points;
                this.displayScore();
            },
            
            displayScore() {
                // Will be implemented in the render cycle
            },
            
            saveHighScore() {
                const newScore = {
                    score: this.score,
                    level: this.currentLevel + 1,
                    date: new Date().toISOString()
                };
                
                this.highScores.push(newScore);
                this.highScores.sort((a, b) => b.score - a.score);
                this.highScores = this.highScores.slice(0, 5); // Keep top 5 scores
                
                // Save to localStorage
                localStorage.setItem('flameWalkerScores', JSON.stringify(this.highScores));
                displayHighScores();
            },
            
            reset() {
                this.score = 0;
                this.lives = 3;
                this.currentLevel = 0;
                this.gameActive = true;
            }
        };
        
        // Player object
        const player = {
            x: 100,
            y: 350,
            width: 20,
            height: 40,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpForce: 12,
            isJumping: false,
            coyoteTime: 0,
            flameSize: 100,
            invincible: false,
            
            update() {
                // Apply gravity
                this.velocityY += 0.5;
                
                // Apply movement from input
                if (gameState.keys.left) this.velocityX = -this.speed;
                else if (gameState.keys.right) this.velocityX = this.speed;
                else this.velocityX = 0;
                
                // Apply jump
                if (gameState.keys.up && (!this.isJumping || this.coyoteTime > 0)) {
                    this.velocityY = -this.jumpForce;
                    this.isJumping = true;
                    this.coyoteTime = 0;
                }
                
                // Update position
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Check level boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                
                // Check for falling off the bottom
                if (this.y > canvas.height) {
                    this.y = canvas.height - this.height;
                    this.velocityY = 0;
                    gameState.lives--;
                    
                    if (gameState.lives <= 0) {
                        endGame();
                    } else {
                        // Reset player position
                        this.resetPosition();
                    }
                }
                
                // Reduce flame size over time
                this.flameSize = Math.max(0, this.flameSize - 0.1);
                
                // Check if flame is out
                if (this.flameSize <= 0) {
                    endGame();
                }
                
                // Decrease coyote time if not on ground
                if (this.coyoteTime > 0) {
                    this.coyoteTime--;
                }
            },
            
            draw(ctx) {
                ctx.save();
                
                // Create center point for the character
                const centerX = this.x + this.width/2;
                
                // Shadow for 3D effect
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                // Create gradient for better 3D effect
                const gradient = ctx.createLinearGradient(
                    centerX - 15, this.y, centerX + 15, this.y + 40
                );
                
                if (this.invincible) {
                    gradient.addColorStop(0, 'rgb(0, 255, 255)');
                    gradient.addColorStop(1, 'rgb(0, 200, 200)');
                } else {
                    gradient.addColorStop(0, 'rgb(255, 50, 50)');
                    gradient.addColorStop(1, 'rgb(200, 0, 0)');
                }
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                
                // Animation offsets for walking
                let legOffsetL = 0;
                let legOffsetR = 0;
                let armOffsetL = 0;
                let armOffsetR = 0;
                
                // Only animate if moving horizontally
                if (Math.abs(this.velocityX) > 0.1) {
                    const walkCycle = (Date.now() % 1000) / 1000;
                    legOffsetL = Math.sin(walkCycle * Math.PI * 2) * 5;
                    legOffsetR = -Math.sin(walkCycle * Math.PI * 2) * 5;
                    armOffsetL = -Math.sin(walkCycle * Math.PI * 2) * 3;
                    armOffsetR = Math.sin(walkCycle * Math.PI * 2) * 3;
                }
                
                // Draw head with gradient
                const headGradient = ctx.createRadialGradient(
                    centerX + 2, this.y - 2, 1, 
                    centerX, this.y, 10
                );
                
                if (this.invincible) {
                    headGradient.addColorStop(0, 'white');
                    headGradient.addColorStop(0.7, 'cyan');
                    headGradient.addColorStop(1, 'blue');
                } else {
                    headGradient.addColorStop(0, 'white');
                    headGradient.addColorStop(0.7, 'red');
                    headGradient.addColorStop(1, 'darkred');
                }
                
                ctx.beginPath();
                ctx.arc(centerX, this.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = headGradient;
                ctx.fill();
                ctx.stroke();
                
                // Draw eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(centerX - 3, this.y - 2, 2, 0, Math.PI * 2);
                ctx.arc(centerX + 3, this.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                
                // Eyes look in direction of movement
                let eyeOffsetX = 0;
                if (this.velocityX > 0.1) eyeOffsetX = 0.5;
                if (this.velocityX < -0.1) eyeOffsetX = -0.5;
                
                ctx.arc(centerX - 3 + eyeOffsetX, this.y - 2, 1, 0, Math.PI * 2);
                ctx.arc(centerX + 3 + eyeOffsetX, this.y - 2, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Body
                ctx.beginPath();
                ctx.moveTo(centerX, this.y + 10);
                ctx.lineTo(centerX, this.y + 30);
                ctx.stroke();
                
                // Arms with animation
                ctx.beginPath();
                ctx.moveTo(centerX, this.y + 15);
                ctx.lineTo(centerX - 10, this.y + 20 + armOffsetL);
                ctx.moveTo(centerX, this.y + 15);
                ctx.lineTo(centerX + 10, this.y + 20 + armOffsetR);
                ctx.stroke();
                
                // Legs with animation - jumping or walking
                if (this.isJumping) {
                    // Jumping pose
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX - 10, this.y + 35);
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX + 10, this.y + 35);
                    ctx.stroke();
                } else {
                    // Walking animation
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX - 8, this.y + 40 + legOffsetL);
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX + 8, this.y + 40 + legOffsetR);
                    ctx.stroke();
                }
                
                // Flame with dynamic size and multi-layer
                const flameHeight = 15 + Math.sin(Date.now() / 100) * 3;
                const flameScale = this.flameSize / 100;
                
                // Outer flame glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 100, 0, 0.7)';
                
                // Base flame
                const flameGradient = ctx.createRadialGradient(
                    centerX, this.y - 15, 1,
                    centerX, this.y - 15, flameHeight * flameScale
                );
                flameGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                flameGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.8)');
                flameGradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.6)');
                flameGradient.addColorStop(1, 'rgba(200, 0, 0, 0)');
                
                ctx.beginPath();
                ctx.moveTo(centerX - 5, this.y - 10);
                ctx.quadraticCurveTo(
                    centerX, 
                    this.y - 10 - flameHeight * flameScale, 
                    centerX + 5, 
                    this.y - 10
                );
                ctx.fillStyle = flameGradient;
                ctx.fill();
                
                // Inner flame (brighter)
                const innerFlameHeight = flameHeight * 0.7;
                const innerFlameGradient = ctx.createRadialGradient(
                    centerX, this.y - 13, 1,
                    centerX, this.y - 13, innerFlameHeight * flameScale
                );
                innerFlameGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                innerFlameGradient.addColorStop(0.5, 'rgba(255, 250, 150, 0.8)');
                innerFlameGradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                
                ctx.beginPath();
                ctx.moveTo(centerX - 3, this.y - 10);
                ctx.quadraticCurveTo(
                    centerX, 
                    this.y - 10 - innerFlameHeight * flameScale, 
                    centerX + 3, 
                    this.y - 10
                );
                ctx.fillStyle = innerFlameGradient;
                ctx.fill();
                
                ctx.restore();
            },
            
            checkPlatformCollisions(platforms) {
                let onGround = false;
                
                platforms.forEach(platform => {
                    if (
                        this.x + this.width > platform.x &&
                        this.x < platform.x + platform.width &&
                        this.y + this.height > platform.y &&
                        this.y + this.height < platform.y + 10 && // Check only the top edge
                        this.velocityY > 0
                    ) {
                        this.y = platform.y - this.height;
                        this.velocityY = 0;
                        this.isJumping = false;
                        onGround = true;
                        this.coyoteTime = 5; // Allow jump slightly after leaving platform
                    }
                });
                
                return onGround;
            },
            
            checkCollectibleCollisions(collectibles) {
                let collectedSomething = false;
                
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const collectible = collectibles[i];
                    
                    if (
                        this.x < collectible.x + collectible.width &&
                        this.x + this.width > collectible.x &&
                        this.y < collectible.y + collectible.height &&
                        this.y + this.height > collectible.y
                    ) {
                        // Handle collectible effect
                        if (collectible.type === 'flame') {
                            gameState.updateScore(collectible.value);
                            this.flameSize = Math.min(100, this.flameSize + 20);
                            collectedSomething = true;
                        } else if (collectible.type === 'powerup') {
                            this.invincible = true;
                            setTimeout(() => {
                                this.invincible = false;
                            }, 3000);
                            collectedSomething = true;
                        }
                        
                        // Remove collectible
                        collectibles.splice(i, 1);
                    }
                }
                
                return collectedSomething;
            },
            
            checkObstacleCollisions(obstacles) {
                for (const obstacle of obstacles) {
                    if (
                        this.x < obstacle.x + obstacle.width &&
                        this.x + this.width > obstacle.x &&
                        this.y < obstacle.y + obstacle.height &&
                        this.y + this.height > obstacle.y
                    ) {
                        if (!this.invincible) {
                            // Handle collision with obstacle
                            this.flameSize = Math.max(0, this.flameSize - 20);
                            this.invincible = true;
                            
                            // Temporary invincibility
                            setTimeout(() => {
                                this.invincible = false;
                            }, 1000);
                            
                            return true;
                        }
                    }
                }
                
                return false;
            },
            
            resetPosition() {
                this.x = 100;
                this.y = 350;
                this.velocityY = 0;
            },
            
            reset() {
                this.resetPosition();
                this.velocityX = 0;
                this.isJumping = false;
                this.flameSize = 100;
                this.invincible = false;
            }
        };
        
        // Level definitions
        const levels = [
            {
                name: "Forest Path",
                backgroundColor1: "#87CEEB",  // Sky blue
                backgroundColor2: "#228B22",  // Forest green
                platforms: [
                    { x: 0, y: 400, width: 200, height: 20 },
                    { x: 250, y: 350, width: 150, height: 20 },
                    { x: 450, y: 300, width: 150, height: 20 }
                ],
                obstacles: [
                    { x: 300, y: 380, width: 50, height: 20, type: 'log' }
                ],
                collectibles: [
                    { x: 400, y: 270, width: 20, height: 20, type: 'flame', value: 10 }
                ]
            },
            {
                name: "Mountain Pass",
                backgroundColor1: "#B0E0E6",  // Powder blue
                backgroundColor2: "#A0522D",  // Sienna
                platforms: [
                    { x: 0, y: 400, width: 150, height: 20 },
                    { x: 200, y: 350, width: 150, height: 20 },
                    { x: 400, y: 300, width: 150, height: 20 },
                    { x: 600, y: 250, width: 150, height: 20 }
                ],
                obstacles: [
                    { x: 250, y: 380, width: 70, height: 20, type: 'boulder' }
                ],
                collectibles: [
                    { x: 300, y: 270, width: 20, height: 20, type: 'flame', value: 15 },
                    { x: 500, y: 220, width: 20, height: 20, type: 'flame', value: 15 }
                ]
            },
            {
                name: "Desert Canyon",
                backgroundColor1: "#87CEFA",  // Light sky blue
                backgroundColor2: "#DAA520",  // Goldenrod
                platforms: [
                    { x: 0, y: 400, width: 120, height: 20 },
                    { x: 180, y: 370, width: 120, height: 20 },
                    { x: 350, y: 340, width: 120, height: 20 },
                    { x: 520, y: 310, width: 120, height: 20 },
                    { x: 690, y: 280, width: 120, height: 20 }
                ],
                obstacles: [
                    { x: 150, y: 380, width: 20, height: 40, type: 'cactus' },
                    { x: 320, y: 350, width: 20, height: 40, type: 'cactus' },
                    { x: 490, y: 320, width: 20, height: 40, type: 'cactus' },
                    { x: 660, y: 290, width: 20, height: 40, type: 'cactus' }
                ],
                collectibles: [
                    { x: 220, y: 340, width: 20, height: 20, type: 'flame', value: 20 },
                    { x: 390, y: 310, width: 20, height: 20, type: 'flame', value: 20 },
                    { x: 560, y: 280, width: 20, height: 20, type: 'flame', value: 20 }
                ]
            }
        ];
        
        // Create backup of original collectibles
        levels.forEach(level => {
            level.originalCollectibles = [...level.collectibles];
        });
        
        // Canvas and context
        let canvas, ctx;
        let gameLoopId = null;
        
        // Initialization
        function init() {
            // Setup canvas
            canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                showError("Canvas element not found");
                return;
            }
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                showError("Failed to get canvas context");
                return;
            }
            
            // Set canvas dimensions to match container
            resizeCanvas();
            
            // Load high scores
            loadHighScores();
            
            // Setup event listeners
            setupInputHandlers();
            setupButtons();
            
            // Initial render of menu
            requestAnimationFrame(() => {
                // Draw a simple background on the menu screen
                drawMenuBackground();
            });
            
            log("Game initialized");
        }
        
        // Resize canvas to fit container
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                log(`Canvas resized to ${canvas.width}x${canvas.height}`);
            }
        }
        
        // Input handling
        function setupInputHandlers() {
            try {
                // Keyboard input
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') gameState.keys.left = true;
                    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') gameState.keys.right = true;
                    if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') gameState.keys.up = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') gameState.keys.left = false;
                    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') gameState.keys.right = false;
                    if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') gameState.keys.up = false;
                });
                
                // Touch controls
                setupTouchControls();
                
                // Window resize
                window.addEventListener('resize', resizeCanvas);
                
                log("Input handlers set up");
            } catch (error) {
                showError("Error setting up input handlers: " + error.message);
            }
        }
        
        function setupTouchControls() {
            try {
                const joystickContainer = document.getElementById('joystickContainer');
                const joystick = document.getElementById('joystick');
                const jumpBtn = document.getElementById('jumpBtn');
                
                if (!joystickContainer || !joystick || !jumpBtn) {
                    showError("Touch control elements not found");
                    return;
                }
                
                // Initially hide controls
                document.getElementById('controls').style.display = 'none';
                
                // Joystick controls
                let joystickActive = false;
                let joystickCenterX, joystickCenterY;
                
                joystickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystickContainer.getBoundingClientRect();
                    joystickCenterX = rect.left + rect.width / 2;
                    joystickCenterY = rect.top + rect.height / 2;
                    
                    joystickActive = true;
                    
                    updateJoystick(touch.clientX, touch.clientY);
                });
                
                joystickContainer.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    e.preventDefault();
                    
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                });
                
                function updateJoystick(touchX, touchY) {
                    const dx = touchX - joystickCenterX;
                    const maxDistance = joystickContainer.clientWidth / 3;
                    
                    // Calculate normalized distance (0 to 1)
                    const distance = Math.min(Math.abs(dx) / maxDistance, 1);
                    
                    // Determine direction
                    if (dx < -10) {
                        gameState.keys.left = true;
                        gameState.keys.right = false;
                        
                        // Move joystick visually
                        const moveX = Math.max(-maxDistance, dx);
                        joystick.style.transform = `translate(calc(-50% + ${moveX}px), -50%)`;
                    } else if (dx > 10) {
                        gameState.keys.right = true;
                        gameState.keys.left = false;
                        
                        // Move joystick visually
                        const moveX = Math.min(maxDistance, dx);
                        joystick.style.transform = `translate(calc(-50% + ${moveX}px), -50%)`;
                    } else {
                        gameState.keys.left = false;
                        gameState.keys.right = false;
                        joystick.style.transform = 'translate(-50%, -50%)';
                    }
                }
                
                window.addEventListener('touchend', (e) => {
                    if (joystickActive) {
                        joystickActive = false;
                        gameState.keys.left = false;
                        gameState.keys.right = false;
                        joystick.style.transform = 'translate(-50%, -50%)';
                    }
                });
                
                // Jump button controls
                jumpBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    gameState.keys.up = true;
                    jumpBtn.style.backgroundColor = 'rgba(255,255,255,0.5)';
                });
                
                jumpBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    gameState.keys.up = false;
                    jumpBtn.style.backgroundColor = 'rgba(255,255,255,0.3)';
                });
                
                log("Touch controls set up");
            } catch (error) {
                showError("Error setting up touch controls: " + error.message);
            }
        }
        
        // Button handling
        function setupButtons() {
            try {
                // Start button
                const startButton = document.getElementById('startButton');
                startButton.addEventListener('click', startGame);
                startButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startGame();
                });
                
                // Restart button
                const restartButton = document.getElementById('restartButton');
                restartButton.addEventListener('click', startGame);
                restartButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startGame();
                });
                
                log("Buttons set up");
            } catch (error) {
                showError("Error setting up buttons: " + error.message);
            }
        }
        
        // Menu background animation
        function drawMenuBackground() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#4682B4');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Ground
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, height * 0.7, width, height * 0.3);
            
            // Sun
            ctx.fillStyle = '#FDB813';
            ctx.beginPath();
            ctx.arc(width * 0.8, height * 0.2, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // Trees
            for (let i = 0; i < 5; i++) {
                const x = width * (0.1 + i * 0.2);
                const y = height * 0.7;
                
                // Trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 5, y - 40, 10, 40);
                
                // Leaves
                ctx.fillStyle = '#006400';
                ctx.beginPath();
                ctx.moveTo(x - 20, y - 30);
                ctx.lineTo(x, y - 70);
                ctx.lineTo(x + 20, y - 30);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(x - 25, y - 50);
                ctx.lineTo(x, y - 90);
                ctx.lineTo(x + 25, y - 50);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Game management
        function startGame() {
            try {
                log("Starting game");
                
                // Reset game state
                gameState.reset();
                
                // Reset player
                player.reset();
                
                // Reset levels and collectibles
                levels.forEach(level => {
                    level.collectibles = [...level.originalCollectibles];
                });
                
                // Hide menu and game over, show game screen
                document.getElementById('menuOverlay').style.display = 'none';
                document.getElementById('gameOverlay').style.display = 'none';
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('controlsInfo').style.display = 'block';
                
                // Show level notification
                showLevelMessage(`Level 1: ${levels[0].name}`);
                
                // Start game loop
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                
                gameLoopId = requestAnimationFrame(gameLoop);
                
                // Hide controls info after 5 seconds
                setTimeout(() => {
                    const controlsInfo = document.getElementById('controlsInfo');
                    if (controlsInfo) {
                        controlsInfo.style.display = 'none';
                    }
                }, 5000);
                
                log("Game started successfully");
            } catch (error) {
                showError("Error starting game: " + error.message);
            }
        }
        
        function endGame() {
            try {
                // Stop game loop
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
                
                gameState.gameActive = false;
                
                // Save high score
                gameState.saveHighScore();
                
                // Update game over display
                document.getElementById('gameOverTitle').textContent = "Game Over";
                document.getElementById('finalScore').textContent = `Score: ${gameState.score}`;
                document.getElementById('finalLevel').textContent = `Level ${gameState.currentLevel + 1}: ${levels[gameState.currentLevel].name}`;
                
                // Show game over screen
                document.getElementById('gameOverlay').style.display = 'flex';
                
                log("Game ended with score: " + gameState.score);
            } catch (error) {
                showError("Error ending game: " + error.message);
            }
        }
        
        function advanceLevel() {
            try {
                // Increase level counter
                gameState.currentLevel++;
                log("Advancing to level: " + gameState.currentLevel);
                
                // Check if all levels are complete
                if (gameState.currentLevel >= levels.length) {
                    document.getElementById('gameOverTitle').textContent = "You Won!";
                    endGame();
                    return;
                }
                
                // Reset player position
                player.resetPosition();
                
                // Add bonus points
                gameState.updateScore(50);
                
                // Show level announcement
                const levelName = levels[gameState.currentLevel].name;
                showLevelMessage(`Level ${gameState.currentLevel + 1}: ${levelName}`);
                
                log("Advanced to level " + gameState.currentLevel);
            } catch (error) {
                showError("Error advancing level: " + error.message);
            }
        }
        
        function showLevelMessage(text) {
            try {
                const levelMessage = document.createElement('div');
                levelMessage.textContent = text;
                levelMessage.style.position = 'absolute';
                levelMessage.style.top = '50%';
                levelMessage.style.left = '50%';
                levelMessage.style.transform = 'translate(-50%, -50%)';
                levelMessage.style.color = 'white';
                levelMessage.style.fontSize = '6vmin';
                levelMessage.style.fontWeight = 'bold';
                levelMessage.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                levelMessage.style.zIndex = '30';
                levelMessage.style.backgroundColor = 'rgba(0,0,0,0.5)';
                levelMessage.style.padding = '10px 20px';
                levelMessage.style.borderRadius = '10px';
                document.getElementById('gameContainer').appendChild(levelMessage);
                
                setTimeout(() => {
                    if (document.getElementById('gameContainer').contains(levelMessage)) {
                        document.getElementById('gameContainer').removeChild(levelMessage);
                    }
                }, 2000);
            } catch (error) {
                console.error("Error showing level message:", error);
            }
        }
        
        // Game rendering
        function drawBackground(level) {
            if (!level) return;
            
            try {
                // Create gradient background
                const startColor = level.backgroundColor1;
                const endColor = level.backgroundColor2;
                
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add environmental details based on level type
                if (level.name.includes("Forest")) {
                    drawForestBackground();
                } else if (level.name.includes("Mountain")) {
                    drawMountainBackground();
                } else if (level.name.includes("Desert")) {
                    drawDesertBackground();
                }
            } catch (error) {
                console.error("Error drawing background:", error);
                ctx.fillStyle = "#333";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        function drawForestBackground() {
            // Draw trees in background
            const treeCount = Math.floor(canvas.width / 50);
            ctx.fillStyle = 'rgba(34, 139, 34, 0.3)'; // Forest green with transparency
            
            for (let i = 0; i < treeCount; i++) {
                const x = i * 50 + 25;
                const y = canvas.height - 50;
                const height = 30 + (i % 3) * 5;
                
                // Tree
                ctx.beginPath();
                ctx.moveTo(x - 10, y);
                ctx.lineTo(x, y - height);
                ctx.lineTo(x + 10, y);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function drawMountainBackground() {
            // Draw mountains
            ctx.fillStyle = 'rgba(105, 105, 105, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 80);
            
            // First mountain
            ctx.lineTo(canvas.width * 0.3, canvas.height * 0.4);
            ctx.lineTo(canvas.width * 0.5, canvas.height - 80);
            
            // Second mountain
            ctx.lineTo(canvas.width * 0.7, canvas.height * 0.5);
            ctx.lineTo(canvas.width, canvas.height - 80);
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawDesertBackground() {
            // Draw sand dunes
            ctx.fillStyle = 'rgba(210, 180, 140, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 30);
            
            for (let x = 0; x <= canvas.width; x += canvas.width / 6) {
                const height = Math.sin(x / canvas.width * Math.PI) * 40;
                ctx.lineTo(x, canvas.height - 30 - height);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawPlatforms(platforms) {
            if (!platforms || !Array.isArray(platforms)) return;
            
            // Calculate scale factor based on canvas size
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 450;
            
            platforms.forEach(platform => {
                // Scale platform dimensions for current canvas size
                const scaledX = platform.x * scaleX;
                const scaledY = platform.y * scaleY;
                const scaledWidth = platform.width * scaleX;
                const scaledHeight = platform.height * scaleY;
                
                // Create platform gradient
                const gradient = ctx.createLinearGradient(
                    scaledX, scaledY, 
                    scaledX, scaledY + scaledHeight
                );
                gradient.addColorStop(0, '#777');
                gradient.addColorStop(0.5, '#555');
                gradient.addColorStop(1, '#333');
                
                // Draw with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 4;
                
                ctx.fillStyle = gradient;
                ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Add highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(scaledX, scaledY, scaledWidth, 2);
            });
        }
        
        function drawObstacles(obstacles) {
            if (!obstacles || !Array.isArray(obstacles)) return;
            
            // Calculate scale factor
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 450;
            
            obstacles.forEach(obstacle => {
                // Scale obstacle dimensions
                const scaledX = obstacle.x * scaleX;
                const scaledY = obstacle.y * scaleY;
                const scaledWidth = obstacle.width * scaleX;
                const scaledHeight = obstacle.height * scaleY;
                
                // Choose color based on type
                switch(obstacle.type) {
                    case 'log':
                        ctx.fillStyle = '#8B4513'; // Brown
                        break;
                    case 'boulder':
                        ctx.fillStyle = '#A9A9A9'; // DarkGray
                        break;
                    case 'cactus':
                        ctx.fillStyle = '#2E8B57'; // SeaGreen
                        break;
                    default:
                        ctx.fillStyle = '#8B4513';
                }
                
                ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                
                // Add effects for certain obstacles
                if (obstacle.type === 'cactus') {
                    // Add cactus spines
                    ctx.strokeStyle = '#98FB98';
                    ctx.beginPath();
                    ctx.moveTo(scaledX + scaledWidth/2, scaledY);
                    ctx.lineTo(scaledX + scaledWidth/2 + 5, scaledY - 5);
                    ctx.moveTo(scaledX + scaledWidth/2, scaledY + scaledHeight/3);
                    ctx.lineTo(scaledX + scaledWidth/2 + 5, scaledY + scaledHeight/3 - 5);
                    ctx.stroke();
                }
            });
        }
        
        function drawCollectibles(collectibles) {
            if (!collectibles || !Array.isArray(collectibles)) return;
            
            // Calculate scale factor
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 450;
            
            collectibles.forEach(collectible => {
                // Scale collectible dimensions
                const scaledX = collectible.x * scaleX;
                const scaledY = collectible.y * scaleY;
                const scaledWidth = collectible.width * scaleX;
                const scaledHeight = collectible.height * scaleY;
                
                if (collectible.type === 'flame') {
                    const centerX = scaledX + scaledWidth/2;
                    const centerY = scaledY + scaledHeight/2;
                    
                    // Flame glow
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                    ctx.shadowBlur = 10;
                    
                    // Flame animation
                    const radius = scaledWidth/2 * (0.8 + Math.sin(Date.now() / 200) * 0.2);
                    
                    // Create flame gradient
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius * 0.3,
                        centerX, centerY, radius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0.6)');
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        function drawUI() {
            // Get current level
            const level = levels[gameState.currentLevel];
            if (!level) return;
            
            // Draw score and lives
            ctx.fillStyle = 'white';
            ctx.font = '4vmin Arial';
            ctx.fillText(`Score: ${gameState.score}`, 20, 30);
            ctx.fillText(`Lives: ${gameState.lives}`, 20, 60);
            
            // Draw level name
            ctx.textAlign = 'center';
            ctx.fillText(level.name, canvas.width/2, 30);
            
            // Draw flame count
            ctx.fillText(`Flames: ${level.collectibles.length}`, canvas.width/2, 60);
            ctx.textAlign = 'left';
            
            // Draw flame meter
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            const meterWidth = canvas.width / 4;
            ctx.fillRect(canvas.width - meterWidth - 20, 20, meterWidth, 15);
            
            const flameWidth = (player.flameSize / 100) * meterWidth;
            ctx.fillStyle = `rgb(
                255, 
                ${Math.min(255, 100 + player.flameSize)}, 
                ${Math.min(255, 50 + player.flameSize / 2)}
            )`;
            ctx.fillRect(canvas.width - meterWidth - 20, 20, flameWidth, 15);
        }
        
        // Game loop
        function gameLoop() {
            if (!gameState.gameActive) return;
            
            try {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Get current level
                const currentLevel = levels[gameState.currentLevel];
                if (!currentLevel) {
                    throw new Error("Level not found: " + gameState.currentLevel);
                }
                
                // Calculate scale factors
                const scaleX = canvas.width / 800;
                const scaleY = canvas.height / 450;
                
                // Apply scaling to player
                player.width = 20 * scaleX;
                player.height = 40 * scaleY;
                player.speed = 5 * scaleX;
                player.jumpForce = 12 * scaleY;
                
                // Draw background
                drawBackground(currentLevel);
                
                // Draw game elements
                drawPlatforms(currentLevel.platforms);
                drawObstacles(currentLevel.obstacles);
                drawCollectibles(currentLevel.collectibles);
                
                // Update player
                player.update();
                
                // Check collisions
                player.checkPlatformCollisions(currentLevel.platforms);
                player.checkObstacleCollisions(currentLevel.obstacles);
                
                if (player.checkCollectibleCollisions(currentLevel.collectibles)) {
                    // Check if level is complete
                    if (currentLevel.collectibles.length === 0) {
                        advanceLevel();
                    }
                }
                
                // Draw player
                player.draw(ctx);
                
                // Draw UI
                drawUI();
                
                // Continue loop
                gameLoopId = requestAnimationFrame(gameLoop);
            } catch (error) {
                showError("Game loop error: " + error.message);
                console.error("Game loop error:", error);
                
                // Try to restart the game loop after an error
                if (gameState.gameActive) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }
        }
        
        // High scores functions
        function displayHighScores() {
            try {
                const highScoresList = document.getElementById('highScoresList');
                
                if (highScoresList) {
                    if (gameState.highScores.length > 0) {
                        highScoresList.innerHTML = gameState.highScores.map((score, index) => 
                            `<div>${index + 1}. ${score.score} - Level ${score.level}</div>`
                        ).join('');
                    } else {
                        highScoresList.innerHTML = "<div>No high scores yet!</div>";
                    }
                }
            } catch (error) {
                console.error("Error displaying high scores:", error);
            }
        }
        
        function loadHighScores() {
            try {
                const savedScores = localStorage.getItem('flameWalkerScores');
                
                if (savedScores) {
                    gameState.highScores = JSON.parse(savedScores);
                }
                
                displayHighScores();
            } catch (error) {
                showError("Error loading high scores: " + error.message);
            }
        }
        
        // Initialize when DOM is ready
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
