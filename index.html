<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flame Walker: Mobile Edition</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(-45deg, #98273c, #bd3f5a, #c0516d, #a4314c);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            font-family: 'Arial', sans-serif;
        }
        
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes flameFlicker {
            0% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff4500, 0 0 30px #ff4500; }
            50% { text-shadow: 0 0 15px #ff8c00, 0 0 25px #ff8c00, 0 0 35px #ff8c00; }
            100% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff4500, 0 0 30px #ff4500; }
        }
        
        #gameContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            max-width: 100vmin;
            max-height: 80vmin;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background-color: #222;
            border-radius: 12px;
        }
        
        #menuOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            z-index: 10;
            color: white;
            text-align: center;
            border-radius: 12px;
        }
        
        #gameTitle {
            color: #ff4500;
            font-size: 10vmin;
            font-weight: bold;
            text-transform: uppercase;
            margin: 0;
            animation: flameFlicker 2s infinite;
            text-shadow: 0 0 10px #ff4500, 0 0 20px #ff4500;
        }
        
        #startButton, #restartButton {
            padding: 15px 30px;
            font-size: 4vmin;
            background: linear-gradient(to right, #ff4500, #ff8c00);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 15px 0;
            width: 60%;
            max-width: 200px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
            position: relative;
            overflow: hidden;
            z-index: 5;
        }
        
        #startButton:active, #restartButton:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(255, 69, 0, 0.3);
        }
        
        #highScores {
            background: rgba(255,100,30,0.2);
            padding: 15px;
            border-radius: 10px;
            width: 80%;
            max-width: 300px;
            margin-top: 5vmin;
            backdrop-filter: blur(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 69, 0, 0.3);
        }
        
        #highScores h2 {
            margin-top: 0;
            font-size: 4vmin;
        }
        
        #highScoresList {
            font-size: 3vmin;
            text-align: left;
            padding-left: 10px;
        }
        
        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30; /* Higher z-index to ensure it's on top */
            color: white;
            border-radius: 12px;
        }
        
        #gameOverlay h1 {
            font-size: 6vmin;
            margin-bottom: 1vmin;
            text-shadow: 0 0 10px rgba(255, 50, 0, 0.8);
        }
        
        #finalScore, #finalLevel {
            font-size: 4vmin;
            margin: 2vmin 0;
        }
        
        #restartButton {
            padding: 15px 30px;
            font-size: 4vmin;
            background: linear-gradient(to right, #ff4500, #ff8c00);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 15px 0;
            width: 60%;
            max-width: 200px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
            position: relative;
            overflow: hidden;
            z-index: 31; /* Make sure the button is clickable */
        }
        
        #controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 5vmin;
            box-sizing: border-box;
            z-index: 15;
            pointer-events: none;
        }
        
        #joystickContainer {
            width: 20vmin;
            height: 20vmin;
            background-color: rgba(255,255,255,0.2);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            margin-bottom: 2vmin;
        }
        
        #joystick {
            width: 8vmin;
            height: 8vmin;
            background-color: rgba(255,255,255,0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #jumpBtn {
            width: 15vmin;
            height: 10vmin;
            background-color: rgba(255,255,255,0.3);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3vmin;
            color: white;
            user-select: none;
            pointer-events: auto;
            margin-bottom: 2vmin;
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
            z-index: 15;
        }
        
        .flame-container {
            position: relative;
            width: 10vmin;
            height: 10vmin;
            transform: translateY(-5vmin);
        }
        
        .flame {
            position: absolute;
            width: 6vmin;
            height: 6vmin;
            background: radial-gradient(circle, yellow, orange 50%, red);
            border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%;
            box-shadow: 0 0 10px #ff4500, 0 0 20px orange;
            animation: flame 1s infinite alternate;
        }
        
        @keyframes flame {
            0% { transform: scale(1); opacity: 0.9; }
            100% { transform: scale(1.1); opacity: 1; }
        }
        
        /* Controls panel for game overlay */
        #controlsInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 2.5vmin;
            z-index: 25;
            display: none;
        }
        
        #debugInfo {
            position: absolute;
            top: 70px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 100;
            display: none;
            max-width: 200px;
            max-height: 100px;
            overflow: auto;
        }
        
        /* Victory overlay styling */
        #victoryOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0,0,0,0.3), rgba(30,30,60,0.8));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 35; /* Higher than game over overlay */
            color: white;
            border-radius: 12px;
            text-align: center;
        }
        
        #victoryOverlay h1 {
            font-size: 7vmin;
            margin: 0 0 2vmin 0;
            color: gold;
            text-shadow: 0 0 10px orange, 0 0 20px red;
            animation: victoryGlow 2s infinite alternate;
        }
        
        @keyframes victoryGlow {
            0% { text-shadow: 0 0 10px orange, 0 0 20px red; }
            100% { text-shadow: 0 0 20px orange, 0 0 40px red, 0 0 60px yellow; }
        }
        
        #victoryMessage {
            font-size: 4vmin;
            max-width: 80%;
            margin: 2vmin 0;
            line-height: 1.4;
        }
        
        #finalVictoryScore {
            font-size: 5vmin;
            margin: 2vmin 0;
            color: gold;
        }
        
        #victoryRestartButton {
            padding: 15px 30px;
            font-size: 4vmin;
            background: linear-gradient(to right, gold, orange);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 15px 0;
            width: 60%;
            max-width: 200px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.5);
            position: relative;
            z-index: 36;
            animation: victoryButtonPulse 2s infinite alternate;
        }
        
        @keyframes victoryButtonPulse {
            0% { transform: scale(1); box-shadow: 0 5px 15px rgba(255, 215, 0, 0.5); }
            100% { transform: scale(1.05); box-shadow: 0 5px 25px rgba(255, 215, 0, 0.8); }
        }
        
        .victory-flames {
            position: absolute;
            width: 100%;
            height: 100px;
            bottom: 0;
            display: flex;
            justify-content: space-around;
            z-index: -1;
        }
        
        .victory-flame {
            width: 40px;
            height: 80px;
            background: radial-gradient(ellipse at bottom, yellow, orange, red);
            border-radius: 50% 50% 20% 20% / 40% 40% 60% 60%;
            filter: blur(2px);
            animation: victoryFlame 3s infinite alternate;
            transform-origin: center bottom;
            opacity: 0.7;
        }
        
        @keyframes victoryFlame {
            0% { height: 60px; opacity: 0.6; }
            50% { height: 90px; opacity: 0.8; }
            100% { height: 70px; opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="menuOverlay">
            <div>
                <h1 id="gameTitle">Flame Walker</h1>
                <div class="flame-container">
                    <div class="flame"></div>
                </div>
            </div>
            
            <button id="startButton">START GAME</button>
            
            <div id="highScores">
                <h2>High Scores</h2>
                <div id="highScoresList"></div>
            </div>
        </div>
        
        <div id="gameOverlay">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="finalScore">Score: 0</p>
            <p id="finalLevel">Level: 1</p>
            <button id="restartButton">RESTART</button>
        </div>
        
        <!-- Victory overlay for game completion -->
        <div id="victoryOverlay">
            <h1>GAME COMPLETED!</h1>
            <p id="victoryMessage">You've mastered all levels and become the true Flame Walker!</p>
            <p id="finalVictoryScore">Final Score: 0</p>
            <button id="victoryRestartButton">PLAY AGAIN</button>
            <div class="victory-flames">
                <div class="victory-flame" style="animation-delay: 0.2s"></div>
                <div class="victory-flame" style="animation-delay: 0.5s"></div>
                <div class="victory-flame" style="animation-delay: 0.8s"></div>
                <div class="victory-flame" style="animation-delay: 1.1s"></div>
                <div class="victory-flame" style="animation-delay: 1.4s"></div>
            </div>
        </div>

        <div id="controls">
            <div id="joystickContainer">
                <div id="joystick"></div>
            </div>
            <div id="jumpBtn">JUMP</div>
        </div>
        
        <div id="controlsInfo">
            <p>Controls:</p>
            <p>Move: Arrow Keys or A/D</p>
            <p>Jump: Up Arrow, W, or Space</p>
        </div>
        
        <div id="debugInfo"></div>
    </div>

    <script>
        // Debug mode
        const DEBUG_MODE = false;
        
        function debugLog(message) {
            if (DEBUG_MODE) {
                console.log(message);
                const debugEl = document.getElementById('debugInfo');
                if (debugEl) {
                    debugEl.style.display = 'block';
                    debugEl.innerHTML += message + "<br>";
                    
                    // Limit debug lines
                    const lines = debugEl.innerHTML.split('<br>');
                    if (lines.length > 10) {
                        debugEl.innerHTML = lines.slice(lines.length - 10).join('<br>');
                    }
                }
            }
        }
        
        function showError(message) {
            console.error(message);
            debugLog("ERROR: " + message);
        }

        // Game state
        const gameState = {
            score: 0,
            lives: 3,
            currentLevel: 0,
            gameActive: false,
            highScores: [],
            keys: {
                left: false,
                right: false,
                up: false
            },
            
            updateScore(points) {
                this.score += points;
            },
            
            // Add the missing saveHighScore method
            saveHighScore() {
                try {
                    // Create a score entry
                    const scoreEntry = {
                        score: this.score,
                        level: this.currentLevel + 1,
                        date: new Date().toLocaleDateString()
                    };
                    
                    // Add to high scores
                    this.highScores.push(scoreEntry);
                    
                    // Sort high scores (highest first)
                    this.highScores.sort((a, b) => b.score - a.score);
                    
                    // Keep only top 5
                    if (this.highScores.length > 5) {
                        this.highScores = this.highScores.slice(0, 5);
                    }
                    
                    // Save to localStorage
                    localStorage.setItem('flameWalkerScores', JSON.stringify(this.highScores));
                    
                    // Update displayed high scores
                    displayHighScores();
                    
                    debugLog("High score saved: " + this.score);
                } catch (error) {
                    showError("Error saving high score: " + error.message);
                }
            },
            
            reset() {
                this.score = 0;
                this.lives = 3;
                this.currentLevel = 0;
                this.gameActive = true;
                debugLog("Game state reset");
            }
        };
        
        // Player object
        const player = {
            x: 100,
            y: 380, // Start directly on a platform 
            width: 20,
            height: 40,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpForce: 12,
            isJumping: false,
            coyoteTime: 0,
            flameSize: 100,
            invincible: false,
            
            update() {
                // Apply gravity
                this.velocityY += 0.5;
                
                // Apply movement from input
                if (gameState.keys.left) {
                    this.velocityX = -this.speed;
                    debugLog("Moving left");
                }
                else if (gameState.keys.right) {
                    this.velocityX = this.speed;
                    debugLog("Moving right");
                }
                else this.velocityX = 0;
                
                // Apply jump
                if (gameState.keys.up && (!this.isJumping || this.coyoteTime > 0)) {
                    this.velocityY = -this.jumpForce;
                    this.isJumping = true;
                    this.coyoteTime = 0;
                    debugLog("Jumping");
                }
                
                // Update position
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Check level boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                
                // Check for falling off the bottom
                if (this.y > canvas.height) {
                    debugLog("Player fell off bottom");
                    
                    gameState.lives--;
                    
                    if (gameState.lives <= 0) {
                        debugLog("No lives left - ending game");
                        endGame();
                    } else {
                        // Reset player position to start of level
                        this.resetPosition();
                    }
                }
                
                // Reduce flame size over time (slower rate for mobile)
                this.flameSize = Math.max(0, this.flameSize - 0.05);
                
                // Check if flame is out
                if (this.flameSize <= 0) {
                    debugLog("Flame out - ending game");
                    endGame();
                }
                
                // Decrease coyote time if not on ground
                if (this.coyoteTime > 0) {
                    this.coyoteTime--;
                }
            },
            
            draw(ctx) {
                ctx.save();
                
                // Create center point for the character
                const centerX = this.x + this.width/2;
                
                // Shadow for 3D effect
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                // Create gradient for better 3D effect
                const gradient = ctx.createLinearGradient(
                    centerX - 15, this.y, centerX + 15, this.y + 40
                );
                
                if (this.invincible) {
                    gradient.addColorStop(0, 'rgb(0, 255, 255)');
                    gradient.addColorStop(1, 'rgb(0, 200, 200)');
                } else {
                    gradient.addColorStop(0, 'rgb(255, 50, 50)');
                    gradient.addColorStop(1, 'rgb(200, 0, 0)');
                }
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                
                // Animation offsets for walking
                let legOffsetL = 0;
                let legOffsetR = 0;
                let armOffsetL = 0;
                let armOffsetR = 0;
                
                // Only animate if moving horizontally
                if (Math.abs(this.velocityX) > 0.1) {
                    const walkCycle = (Date.now() % 1000) / 1000;
                    legOffsetL = Math.sin(walkCycle * Math.PI * 2) * 5;
                    legOffsetR = -Math.sin(walkCycle * Math.PI * 2) * 5;
                    armOffsetL = -Math.sin(walkCycle * Math.PI * 2) * 3;
                    armOffsetR = Math.sin(walkCycle * Math.PI * 2) * 3;
                }
                
                // Draw head with gradient
                const headGradient = ctx.createRadialGradient(
                    centerX + 2, this.y - 2, 1, 
                    centerX, this.y, 10
                );
                
                if (this.invincible) {
                    headGradient.addColorStop(0, 'white');
                    headGradient.addColorStop(0.7, 'cyan');
                    headGradient.addColorStop(1, 'blue');
                } else {
                    headGradient.addColorStop(0, 'white');
                    headGradient.addColorStop(0.7, 'red');
                    headGradient.addColorStop(1, 'darkred');
                }
                
                ctx.beginPath();
                ctx.arc(centerX, this.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = headGradient;
                ctx.fill();
                ctx.stroke();
                
                // Draw eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(centerX - 3, this.y - 2, 2, 0, Math.PI * 2);
                ctx.arc(centerX + 3, this.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                
                // Eyes look in direction of movement
                let eyeOffsetX = 0;
                if (this.velocityX > 0.1) eyeOffsetX = 0.5;
                if (this.velocityX < -0.1) eyeOffsetX = -0.5;
                
                ctx.arc(centerX - 3 + eyeOffsetX, this.y - 2, 1, 0, Math.PI * 2);
                ctx.arc(centerX + 3 + eyeOffsetX, this.y - 2, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Body
                ctx.beginPath();
                ctx.moveTo(centerX, this.y + 10);
                ctx.lineTo(centerX, this.y + 30);
                ctx.stroke();
                
                // Arms with animation
                ctx.beginPath();
                ctx.moveTo(centerX, this.y + 15);
                ctx.lineTo(centerX - 10, this.y + 20 + armOffsetL);
                ctx.moveTo(centerX, this.y + 15);
                ctx.lineTo(centerX + 10, this.y + 20 + armOffsetR);
                ctx.stroke();
                
                // Legs with animation - jumping or walking
                if (this.isJumping) {
                    // Jumping pose
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX - 10, this.y + 35);
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX + 10, this.y + 35);
                    ctx.stroke();
                } else {
                    // Walking animation
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX - 8, this.y + 40 + legOffsetL);
                    ctx.moveTo(centerX, this.y + 30);
                    ctx.lineTo(centerX + 8, this.y + 40 + legOffsetR);
                    ctx.stroke();
                }
                
                // Flame with dynamic size and multi-layer
                const flameHeight = 15 + Math.sin(Date.now() / 100) * 3;
                const flameScale = this.flameSize / 100;
                
                // Outer flame glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 100, 0, 0.7)';
                
                // Base flame
                const flameGradient = ctx.createRadialGradient(
                    centerX, this.y - 15, 1,
                    centerX, this.y - 15, flameHeight * flameScale
                );
                flameGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                flameGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.8)');
                flameGradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.6)');
                flameGradient.addColorStop(1, 'rgba(200, 0, 0, 0)');
                
                ctx.beginPath();
                ctx.moveTo(centerX - 5, this.y - 10);
                ctx.quadraticCurveTo(
                    centerX, 
                    this.y - 10 - flameHeight * flameScale, 
                    centerX + 5, 
                    this.y - 10
                );
                ctx.fillStyle = flameGradient;
                ctx.fill();
                
                // Inner flame (brighter)
                const innerFlameHeight = flameHeight * 0.7;
                const innerFlameGradient = ctx.createRadialGradient(
                    centerX, this.y - 13, 1,
                    centerX, this.y - 13, innerFlameHeight * flameScale
                );
                innerFlameGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                innerFlameGradient.addColorStop(0.5, 'rgba(255, 250, 150, 0.8)');
                innerFlameGradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                
                ctx.beginPath();
                ctx.moveTo(centerX - 3, this.y - 10);
                ctx.quadraticCurveTo(
                    centerX, 
                    this.y - 10 - innerFlameHeight * flameScale, 
                    centerX + 3, 
                    this.y - 10
                );
                ctx.fillStyle = innerFlameGradient;
                ctx.fill();
                
                ctx.restore();
            },
            
            checkPlatformCollisions(platforms) {
                let onGround = false;
                
                platforms.forEach(platform => {
                    // Get scaled platform coordinates
                    const scaleX = canvas.width / 800;
                    const scaleY = canvas.height / 450;
                    
                    const scaledX = platform.x * scaleX;
                    const scaledY = platform.y * scaleY;
                    const scaledWidth = platform.width * scaleX;
                    const scaledHeight = platform.height * scaleY;
                    
                    // Improved collision detection with better tolerance
                    if (
                        this.x + this.width > scaledX &&
                        this.x < scaledX + scaledWidth &&
                        this.y + this.height > scaledY - 5 &&  // Added tolerance
                        this.y + this.height < scaledY + scaledHeight/2 && // Check only upper half
                        this.velocityY > 0  // Only detect when falling
                    ) {
                        this.y = scaledY - this.height;
                        this.velocityY = 0;
                        this.isJumping = false;
                        onGround = true;
                        this.coyoteTime = 5; // Allow jump slightly after leaving platform
                    }
                });
                
                return onGround;
            },
            
            checkCollectibleCollisions(collectibles) {
                let collectedSomething = false;
                
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const collectible = collectibles[i];
                    
                    // Get scaled collectible coordinates
                    const scaleX = canvas.width / 800;
                    const scaleY = canvas.height / 450;
                    
                    const scaledX = collectible.x * scaleX;
                    const scaledY = collectible.y * scaleY;
                    const scaledWidth = collectible.width * scaleX;
                    const scaledHeight = collectible.height * scaleY;
                    
                    // Check collision
                    if (
                        this.x < scaledX + scaledWidth &&
                        this.x + this.width > scaledX &&
                        this.y < scaledY + scaledHeight &&
                        this.y + this.height > scaledY
                    ) {
                        // Handle collectible effect
                        if (collectible.type === 'flame') {
                            gameState.updateScore(collectible.value);
                            this.flameSize = Math.min(100, this.flameSize + 20);
                            collectedSomething = true;
                            debugLog("Collected flame");
                        } else if (collectible.type === 'powerup') {
                            this.invincible = true;
                            gameState.updateScore(collectible.value || 30);
                            setTimeout(() => {
                                this.invincible = false;
                            }, 3000);
                            collectedSomething = true;
                            debugLog("Collected powerup");
                        } else if (collectible.type === 'superflame') {
                            gameState.updateScore(collectible.value || 50);
                            this.flameSize = 100; // Full flame
                            collectedSomething = true;
                            debugLog("Collected superflame");
                        }
                        
                        // Remove collectible
                        collectibles.splice(i, 1);
                    }
                }
                
                return collectedSomething;
            },
            
            checkObstacleCollisions(obstacles) {
                for (const obstacle of obstacles) {
                    // Get scaled obstacle coordinates
                    const scaleX = canvas.width / 800;
                    const scaleY = canvas.height / 450;
                    
                    const scaledX = obstacle.x * scaleX;
                    const scaledY = obstacle.y * scaleY;
                    const scaledWidth = obstacle.width * scaleX;
                    const scaledHeight = obstacle.height * scaleY;
                    
                    // Check collision
                    if (
                        this.x < scaledX + scaledWidth &&
                        this.x + this.width > scaledX &&
                        this.y < scaledY + scaledHeight &&
                        this.y + this.height > scaledY
                    ) {
                        if (!this.invincible) {
                            // Handle collision with obstacle
                            this.flameSize = Math.max(0, this.flameSize - 20);
                            this.invincible = true;
                            debugLog("Hit obstacle");
                            
                            // Temporary invincibility
                            setTimeout(() => {
                                this.invincible = false;
                            }, 1000);
                            
                            return true;
                        }
                    }
                }
                
                return false;
            },
            
            resetPosition() {
                this.x = 100;
                this.y = 380; // Place directly on platform
                this.velocityY = 0;
                debugLog("Player position reset");
            },
            
            reset() {
                this.resetPosition();
                this.velocityX = 0;
                this.isJumping = false;
                this.flameSize = 100;
                this.invincible = false;
                debugLog("Player fully reset");
            }
        };
        
        // Level definitions - Extended to 10 levels
        const levels = [
            {
                name: "Forest Path",
                backgroundColor1: "#87CEEB",  // Sky blue
                backgroundColor2: "#228B22",  // Forest green
                platforms: [
                    { x: 0, y: 400, width: 200, height: 20 },
                    { x: 250, y: 350, width: 150, height: 20 },
                    { x: 450, y: 300, width: 150, height: 20 }
                ],
                obstacles: [
                    { x: 300, y: 380, width: 50, height: 20, type: 'log' }
                ],
                collectibles: [
                    { x: 400, y: 270, width: 20, height: 20, type: 'flame', value: 10 }
                ]
            },
            {
                name: "Mountain Pass",
                backgroundColor1: "#B0E0E6",  // Powder blue
                backgroundColor2: "#A0522D",  // Sienna
                platforms: [
                    { x: 0, y: 400, width: 150, height: 20 },
                    { x: 200, y: 350, width: 150, height: 20 },
                    { x: 400, y: 300, width: 150, height: 20 },
                    { x: 600, y: 250, width: 150, height: 20 }
                ],
                obstacles: [
                    { x: 250, y: 380, width: 70, height: 20, type: 'boulder' }
                ],
                collectibles: [
                    { x: 300, y: 270, width: 20, height: 20, type: 'flame', value: 15 },
                    { x: 500, y: 220, width: 20, height: 20, type: 'flame', value: 15 }
                ]
            },
            {
                name: "Desert Canyon",
                backgroundColor1: "#87CEFA",  // Light sky blue
                backgroundColor2: "#DAA520",  // Goldenrod
                platforms: [
                    { x: 0, y: 400, width: 120, height: 20 },
                    { x: 180, y: 370, width: 120, height: 20 },
                    { x: 350, y: 340, width: 120, height: 20 },
                    { x: 520, y: 310, width: 120, height: 20 },
                    { x: 690, y: 280, width: 120, height: 20 }
                ],
                obstacles: [
                    { x: 150, y: 380, width: 20, height: 40, type: 'cactus' },
                    { x: 320, y: 350, width: 20, height: 40, type: 'cactus' },
                    { x: 490, y: 320, width: 20, height: 40, type: 'cactus' },
                    { x: 660, y: 290, width: 20, height: 40, type: 'cactus' }
                ],
                collectibles: [
                    { x: 220, y: 340, width: 20, height: 20, type: 'flame', value: 20 },
                    { x: 390, y: 310, width: 20, height: 20, type: 'flame', value: 20 },
                    { x: 560, y: 280, width: 20, height: 20, type: 'flame', value: 20 }
                ]
            },
            // New levels added
            {
                name: "Cave Depths",
                backgroundColor1: "#2C3E50",  // Dark blue
                backgroundColor2: "#34495E",  // Slightly lighter dark blue
                platforms: [
                    { x: 0, y: 400, width: 100, height: 20 },
                    { x: 160, y: 350, width: 100, height: 20 },
                    { x: 320, y: 380, width: 100, height: 20 },
                    { x: 480, y: 330, width: 100, height: 20 },
                    { x: 640, y: 290, width: 100, height: 20 }
                ],
                obstacles: [
                    { x: 200, y: 290, width: 30, height: 60, type: 'stalactite' },
                    { x: 400, y: 270, width: 30, height: 60, type: 'stalactite' },
                    { x: 600, y: 230, width: 30, height: 60, type: 'stalactite' }
                ],
                collectibles: [
                    { x: 180, y: 320, width: 20, height: 20, type: 'flame', value: 25 },
                    { x: 350, y: 350, width: 20, height: 20, type: 'flame', value: 25 },
                    { x: 510, y: 300, width: 20, height: 20, type: 'flame', value: 25 },
                    { x: 670, y: 260, width: 20, height: 20, type: 'powerup', value: 30 }
                ]
            },
            {
                name: "Ice Peak",
                backgroundColor1: "#E0FFFF",  // Light cyan
                backgroundColor2: "#B0E0E6",  // Powder blue
                platforms: [
                    { x: 0, y: 400, width: 120, height: 10 },
                    { x: 180, y: 370, width: 120, height: 10 },
                    { x: 360, y: 340, width: 120, height: 10 },
                    { x: 540, y: 310, width: 120, height: 10 },
                    { x: 720, y: 280, width: 80, height: 10 }
                ],
                obstacles: [
                    { x: 100, y: 380, width: 70, height: 15, type: 'ice' },
                    { x: 280, y: 350, width: 70, height: 15, type: 'ice' },
                    { x: 460, y: 320, width: 70, height: 15, type: 'ice' },
                    { x: 640, y: 290, width: 70, height: 15, type: 'ice' }
                ],
                collectibles: [
                    { x: 70, y: 370, width: 20, height: 20, type: 'flame', value: 30 },
                    { x: 250, y: 340, width: 20, height: 20, type: 'flame', value: 30 },
                    { x: 430, y: 310, width: 20, height: 20, type: 'flame', value: 30 },
                    { x: 610, y: 280, width: 20, height: 20, type: 'flame', value: 30 },
                    { x: 740, y: 250, width: 20, height: 20, type: 'superflame', value: 50 }
                ]
            },
            {
                name: "Volcanic Summit",
                backgroundColor1: "#8B0000",  // Dark red
                backgroundColor2: "#FF4500",  // Orange red
                platforms: [
                    { x: 0, y: 400, width: 100, height: 20 },
                    { x: 160, y: 360, width: 100, height: 20 },
                    { x: 320, y: 330, width: 100, height: 20 },
                    { x: 480, y: 290, width: 100, height: 20 },
                    { x: 640, y: 250, width: 100, height: 20 },
                    { x: 480, y: 200, width: 80, height: 20 },
                    { x: 320, y: 160, width: 80, height: 20 }
                ],
                obstacles: [
                    { x: 130, y: 380, width: 30, height: 20, type: 'lava' },
                    { x: 290, y: 340, width: 30, height: 20, type: 'lava' },
                    { x: 450, y: 310, width: 30, height: 20, type: 'lava' },
                    { x: 610, y: 270, width: 30, height: 20, type: 'lava' },
                    { x: 450, y: 220, width: 30, height: 20, type: 'lava' }
                ],
                collectibles: [
                    { x: 60, y: 370, width: 20, height: 20, type: 'flame', value: 35 },
                    { x: 220, y: 330, width: 20, height: 20, type: 'flame', value: 35 },
                    { x: 380, y: 300, width: 20, height: 20, type: 'flame', value: 35 },
                    { x: 540, y: 260, width: 20, height: 20, type: 'flame', value: 35 },
                    { x: 700, y: 220, width: 20, height: 20, type: 'flame', value: 35 },
                    { x: 540, y: 170, width: 20, height: 20, type: 'powerup', value: 40 },
                    { x: 380, y: 130, width: 20, height: 20, type: 'superflame', value: 50 }
                ]
            },
            {
                name: "Ancient Temple",
                backgroundColor1: "#704214",  // Brown
                backgroundColor2: "#8B4513",  // SaddleBrown
                platforms: [
                    { x: 0, y: 400, width: 120, height: 20 },
                    { x: 180, y: 350, width: 120, height: 20 },
                    { x: 360, y: 400, width: 120, height: 20 },
                    { x: 540, y: 350, width: 120, height: 20 },
                    { x: 720, y: 300, width: 80, height: 20 },
                    { x: 540, y: 250, width: 120, height: 20 },
                    { x: 360, y: 200, width: 120, height: 20 },
                    { x: 180, y: 150, width: 120, height: 20 }
                ],
                obstacles: [
                    { x: 150, y: 380, width: 20, height: 40, type: 'spike' },
                    { x: 330, y: 380, width: 20, height: 40, type: 'spike' },
                    { x: 510, y: 330, width: 20, height: 40, type: 'spike' },
                    { x: 690, y: 280, width: 20, height: 40, type: 'spike' },
                    { x: 510, y: 230, width: 20, height: 40, type: 'spike' },
                    { x: 330, y: 180, width: 20, height: 40, type: 'spike' }
                ],
                collectibles: [
                    { x: 60, y: 370, width: 20, height: 20, type: 'flame', value: 40 },
                    { x: 240, y: 320, width: 20, height: 20, type: 'flame', value: 40 },
                    { x: 420, y: 370, width: 20, height: 20, type: 'flame', value: 40 },
                    { x: 600, y: 320, width: 20, height: 20, type: 'flame', value: 40 },
                    { x: 750, y: 270, width: 20, height: 20, type: 'powerup', value: 50 },
                    { x: 600, y: 220, width: 20, height: 20, type: 'flame', value: 40 },
                    { x: 420, y: 170, width: 20, height: 20, type: 'flame', value: 40 },
                    { x: 240, y: 120, width: 20, height: 20, type: 'superflame', value: 60 }
                ]
            },
            {
                name: "Crystal Cavern",
                backgroundColor1: "#191970",  // MidnightBlue
                backgroundColor2: "#483D8B",  // DarkSlateBlue
                platforms: [
                    { x: 0, y: 400, width: 100, height: 20 },
                    { x: 150, y: 350, width: 100, height: 20 },
                    { x: 300, y: 300, width: 100, height: 20 },
                    { x: 450, y: 250, width: 100, height: 20 },
                    { x: 600, y: 200, width: 100, height: 20 },
                    { x: 450, y: 150, width: 100, height: 20 },
                    { x: 300, y: 100, width: 100, height: 20 }
                ],
                obstacles: [
                    { x: 120, y: 380, width: 30, height: 40, type: 'crystal' },
                    { x: 270, y: 330, width: 30, height: 40, type: 'crystal' },
                    { x: 420, y: 280, width: 30, height: 40, type: 'crystal' },
                    { x: 570, y: 230, width: 30, height: 40, type: 'crystal' },
                    { x: 420, y: 180, width: 30, height: 40, type: 'crystal' }
                ],
                collectibles: [
                    { x: 50, y: 370, width: 20, height: 20, type: 'flame', value: 45 },
                    { x: 200, y: 320, width: 20, height: 20, type: 'flame', value: 45 },
                    { x: 350, y: 270, width: 20, height: 20, type: 'flame', value: 45 },
                    { x: 500, y: 220, width: 20, height: 20, type: 'flame', value: 45 },
                    { x: 650, y: 170, width: 20, height: 20, type: 'powerup', value: 60 },
                    { x: 500, y: 120, width: 20, height: 20, type: 'superflame', value: 70 },
                    { x: 350, y: 70, width: 20, height: 20, type: 'superflame', value: 80 }
                ]
            },
            {
                name: "Sky Islands",
                backgroundColor1: "#00BFFF",  // DeepSkyBlue
                backgroundColor2: "#87CEEB",  // SkyBlue
                platforms: [
                    { x: 0, y: 400, width: 100, height: 20 },
                    { x: 160, y: 350, width: 80, height: 20 },
                    { x: 300, y: 380, width: 80, height: 20 },
                    { x: 440, y: 330, width: 80, height: 20 },
                    { x: 580, y: 360, width: 80, height: 20 },
                    { x: 720, y: 310, width: 80, height: 20 },
                    { x: 580, y: 260, width: 80, height: 20 },
                    { x: 440, y: 210, width: 80, height: 20 },
                    { x: 300, y: 160, width: 80, height: 20 },
                    { x: 160, y: 110, width: 80, height: 20 }
                ],
                obstacles: [
                    { x: 130, y: 380, width: 30, height: 20, type: 'cloud' },
                    { x: 270, y: 360, width: 30, height: 20, type: 'cloud' },
                    { x: 410, y: 310, width: 30, height: 20, type: 'cloud' },
                    { x: 550, y: 340, width: 30, height: 20, type: 'cloud' },
                    { x: 690, y: 290, width: 30, height: 20, type: 'cloud' },
                    { x: 550, y: 240, width: 30, height: 20, type: 'cloud' },
                    { x: 410, y: 190, width: 30, height: 20, type: 'cloud' },
                    { x: 270, y: 140, width: 30, height: 20, type: 'cloud' }
                ],
                collectibles: [
                    { x: 50, y: 370, width: 20, height: 20, type: 'flame', value: 50 },
                    { x: 200, y: 320, width: 20, height: 20, type: 'flame', value: 50 },
                    { x: 340, y: 350, width: 20, height: 20, type: 'flame', value: 50 },
                    { x: 480, y: 300, width: 20, height: 20, type: 'flame', value: 50 },
                    { x: 620, y: 330, width: 20, height: 20, type: 'flame', value: 50 },
                    { x: 760, y: 280, width: 20, height: 20, type: 'flame', value: 50 },
                    { x: 620, y: 230, width: 20, height: 20, type: 'powerup', value: 70 },
                    { x: 480, y: 180, width: 20, height: 20, type: 'flame', value: 50 },
                    { x: 340, y: 130, width: 20, height: 20, type: 'superflame', value: 80 },
                    { x: 200, y: 80, width: 20, height: 20, type: 'superflame', value: 100 }
                ]
            },
            {
                name: "Flame Core",
                backgroundColor1: "#800000",  // Maroon
                backgroundColor2: "#8B0000",  // DarkRed
                platforms: [
                    { x: 0, y: 400, width: 80, height: 15 },
                    { x: 140, y: 370, width: 80, height: 15 },
                    { x: 280, y: 340, width: 80, height: 15 },
                    { x: 420, y: 310, width: 80, height: 15 },
                    { x: 560, y: 280, width: 80, height: 15 },
                    { x: 700, y: 250, width: 80, height: 15 },
                    { x: 560, y: 220, width: 80, height: 15 },
                    { x: 420, y: 190, width: 80, height: 15 },
                    { x: 280, y: 160, width: 80, height: 15 },
                    { x: 140, y: 130, width: 80, height: 15 },
                    { x: 0, y: 100, width: 80, height: 15 }
                ],
                obstacles: [
                    { x: 100, y: 385, width: 40, height: 15, type: 'lava' },
                    { x: 240, y: 355, width: 40, height: 15, type: 'lava' },
                    { x: 380, y: 325, width: 40, height: 15, type: 'lava' },
                    { x: 520, y: 295, width: 40, height: 15, type: 'lava' },
                    { x: 660, y: 265, width: 40, height: 15, type: 'lava' },
                    { x: 520, y: 235, width: 40, height: 15, type: 'lava' },
                    { x: 380, y: 205, width: 40, height: 15, type: 'lava' },
                    { x: 240, y: 175, width: 40, height: 15, type: 'lava' },
                    { x: 100, y: 145, width: 40, height: 15, type: 'lava' }
                ],
                collectibles: [
                    { x: 40, y: 370, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 180, y: 340, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 320, y: 310, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 460, y: 280, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 600, y: 250, width: 20, height: 20, type: 'powerup', value: 80 },
                    { x: 740, y: 220, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 600, y: 190, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 460, y: 160, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 320, y: 130, width: 20, height: 20, type: 'flame', value: 60 },
                    { x: 180, y: 100, width: 20, height: 20, type: 'superflame', value: 100 },
                    { x: 40, y: 70, width: 20, height: 20, type: 'superflame', value: 200 }
                ]
            }
        ];
        
        // Create backup of original collectibles
        levels.forEach(level => {
            level.originalCollectibles = JSON.parse(JSON.stringify(level.collectibles));
        });
        
        // Canvas and context
        let canvas, ctx;
        let gameLoopId = null;
        
        // Initialization
        function init() {
            debugLog("Initializing game...");
            
            // Setup canvas
            canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                showError("Canvas element not found");
                return;
            }
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                showError("Failed to get canvas context");
                return;
            }
            
            // Set canvas dimensions to match container
            resizeCanvas();
            
            // Load high scores
            loadHighScores();
            
            // Setup event listeners
            setupInputHandlers();
            setupButtons();
            
            // Initial render of menu
            requestAnimationFrame(() => {
                // Draw a simple background on the menu screen
                drawMenuBackground();
            });
            
            debugLog("Game initialized");
        }
        
        // Resize canvas to fit container
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                debugLog(`Canvas resized to ${canvas.width}x${canvas.height}`);
            }
        }
        
        // Input handling
        function setupInputHandlers() {
            try {
                // Keyboard input
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') gameState.keys.left = true;
                    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') gameState.keys.right = true;
                    if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') gameState.keys.up = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') gameState.keys.left = false;
                    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') gameState.keys.right = false;
                    if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') gameState.keys.up = false;
                });
                
                // Touch controls
                setupTouchControls();
                
                // Window resize
                window.addEventListener('resize', resizeCanvas);
                
                debugLog("Input handlers set up");
            } catch (error) {
                showError("Error setting up input handlers: " + error.message);
            }
        }
        
        function setupTouchControls() {
            try {
                const joystickContainer = document.getElementById('joystickContainer');
                const joystick = document.getElementById('joystick');
                const jumpBtn = document.getElementById('jumpBtn');
                
                if (!joystickContainer || !joystick || !jumpBtn) {
                    showError("Touch control elements not found");
                    return;
                }
                
                // Initially hide controls
                document.getElementById('controls').style.display = 'none';
                
                // Joystick controls - improved for mobile
                let joystickActive = false;
                
                joystickContainer.addEventListener('touchstart', handleJoystickTouch);
                joystickContainer.addEventListener('touchmove', handleJoystickTouch);
                joystickContainer.addEventListener('touchend', handleJoystickEnd);
                
                function handleJoystickTouch(e) {
                    e.preventDefault();
                    joystickActive = true;
                    
                    const touch = e.touches[0];
                    const rect = joystickContainer.getBoundingClientRect();
                    
                    // Calculate center of joystick container
                    const centerX = rect.left + rect.width/2;
                    const centerY = rect.top + rect.height/2;
                    
                    // Calculate touch position relative to center
                    const touchX = touch.clientX - centerX;
                    const touchY = touch.clientY - centerY;
                    
                    // Calculate distance from center
                    const distance = Math.sqrt(touchX * touchX + touchY * touchY);
                    const maxDistance = rect.width/2 - joystick.clientWidth/2;
                    
                    // If touch is within joystick container radius
                    if (distance <= rect.width/2) {
                        // Normalize position within maxDistance
                        const normDistance = Math.min(distance, maxDistance);
                        const angle = Math.atan2(touchY, touchX);
                        
                        // Calculate joystick position
                        const moveX = normDistance * Math.cos(angle);
                        const moveY = normDistance * Math.sin(angle);
                        
                        // Move joystick
                        joystick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
                        
                        // Set direction based on horizontal movement
                        if (touchX < -10) {
                            gameState.keys.left = true;
                            gameState.keys.right = false;
                            debugLog("Touch: Moving left");
                        } else if (touchX > 10) {
                            gameState.keys.right = true;
                            gameState.keys.left = false;
                            debugLog("Touch: Moving right");
                        } else {
                            gameState.keys.left = false;
                            gameState.keys.right = false;
                        }
                    }
                }
                
                function handleJoystickEnd(e) {
                    e.preventDefault();
                    joystickActive = false;
                    gameState.keys.left = false;
                    gameState.keys.right = false;
                    joystick.style.transform = 'translate(-50%, -50%)';
                    debugLog("Touch: Joystick released");
                }
                
                // Jump button controls
                jumpBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    gameState.keys.up = true;
                    jumpBtn.style.backgroundColor = 'rgba(255,255,255,0.5)';
                    debugLog("Touch: Jump pressed");
                });
                
                jumpBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    gameState.keys.up = false;
                    jumpBtn.style.backgroundColor = 'rgba(255,255,255,0.3)';
                    debugLog("Touch: Jump released");
                });
                
                debugLog("Touch controls set up");
            } catch (error) {
                showError("Error setting up touch controls: " + error.message);
            }
        }
        
        // Button handling
        function setupButtons() {
            try {
                // Start button
                const startButton = document.getElementById('startButton');
                startButton.addEventListener('click', startGame);
                startButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startGame();
                });
                
                // Restart button
                const restartButton = document.getElementById('restartButton');
                restartButton.addEventListener('click', startGame);
                restartButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startGame();
                });
                
                // Victory restart button
                const victoryRestartButton = document.getElementById('victoryRestartButton');
                if (victoryRestartButton) {
                    victoryRestartButton.addEventListener('click', startGame);
                    victoryRestartButton.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        startGame();
                    });
                }
                
                debugLog("Buttons set up");
            } catch (error) {
                showError("Error setting up buttons: " + error.message);
            }
        }
        
        // Menu background animation
        function drawMenuBackground() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#4682B4');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Ground
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, height * 0.7, width, height * 0.3);
            
            // Sun
            ctx.fillStyle = '#FDB813';
            ctx.beginPath();
            ctx.arc(width * 0.8, height * 0.2, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // Trees
            for (let i = 0; i < 5; i++) {
                const x = width * (0.1 + i * 0.2);
                const y = height * 0.7;
                
                // Trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 5, y - 40, 10, 40);
                
                // Leaves
                ctx.fillStyle = '#006400';
                ctx.beginPath();
                ctx.moveTo(x - 20, y - 30);
                ctx.lineTo(x, y - 70);
                ctx.lineTo(x + 20, y - 30);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(x - 25, y - 50);
                ctx.lineTo(x, y - 90);
                ctx.lineTo(x + 25, y - 50);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Game management
        function startGame() {
            try {
                debugLog("Starting game");
                
                // Reset game state
                gameState.reset();
                
                // Reset player
                player.reset();
                
                // Calculate the platform Y position with scaling
                const firstPlatformY = levels[0].platforms[0].y * (canvas.height / 450) - player.height;
                player.y = firstPlatformY; // Position player directly on the first platform
                
                // Reset levels and collectibles
                levels.forEach(level => {
                    level.collectibles = JSON.parse(JSON.stringify(level.originalCollectibles));
                });
                
                // Hide all overlays
                document.getElementById('menuOverlay').style.display = 'none';
                document.getElementById('gameOverlay').style.display = 'none';
                document.getElementById('victoryOverlay').style.display = 'none';
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('controlsInfo').style.display = 'block';
                
                // Show level notification
                showLevelMessage(`Level 1: ${levels[0].name}`);
                
                // Start game loop
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                
                // Make sure debug info is hidden
                document.getElementById('debugInfo').style.display = 'none';
                
                gameLoopId = requestAnimationFrame(gameLoop);
                
                // Hide controls info after 5 seconds
                setTimeout(() => {
                    const controlsInfo = document.getElementById('controlsInfo');
                    if (controlsInfo) {
                        controlsInfo.style.display = 'none';
                    }
                }, 5000);
                
                debugLog("Game started successfully");
            } catch (error) {
                showError("Error starting game: " + error.message);
            }
        }
        
        function endGame() {
            try {
                debugLog("Game ending");
                
                // Stop game loop
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
                
                gameState.gameActive = false;
                
                // Save high score
                gameState.saveHighScore();
                
                // Hide controls
                document.getElementById('controls').style.display = 'none';
                
                // Check if all levels were completed
                if (gameState.currentLevel >= levels.length) {
                    // Show victory screen
                    showVictoryScreen();
                } else {
                    // Update game over display
                    document.getElementById('gameOverTitle').textContent = "Game Over";
                    
                    // Make sure we don't go out of bounds
                    const levelIndex = Math.min(gameState.currentLevel, levels.length - 1);
                    const levelName = levels[levelIndex].name;
                    
                    document.getElementById('finalScore').textContent = `Score: ${gameState.score}`;
                    document.getElementById('finalLevel').textContent = `Level ${levelIndex + 1}: ${levelName}`;
                    
                    // Show game over screen
                    document.getElementById('gameOverlay').style.display = 'flex';
                    
                    // Make restart button more noticeable
                    const restartButton = document.getElementById('restartButton');
                    if (restartButton) {
                        restartButton.style.animation = 'pulse 1.5s infinite';
                        restartButton.style.boxShadow = '0 0 20px rgba(255, 69, 0, 0.7)';
                    }
                }
                
                // Add a pulse animation if it doesn't exist
                if (!document.getElementById('pulse-animation')) {
                    const style = document.createElement('style');
                    style.id = 'pulse-animation';
                    style.textContent = `
                        @keyframes pulse {
                            0% { transform: scale(1); }
                            50% { transform: scale(1.1); }
                            100% { transform: scale(1); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                debugLog("Game ended with score: " + gameState.score);
            } catch (error) {
                showError("Error ending game: " + error.message);
            }
        }
        
        function showVictoryScreen() {
            try {
                // Update victory screen content
                document.getElementById('finalVictoryScore').textContent = `Final Score: ${gameState.score}`;
                
                // Show the victory overlay
                document.getElementById('victoryOverlay').style.display = 'flex';
                
                // Add some celebration effects
                createVictoryEffects();
                
                debugLog("Victory screen shown with score: " + gameState.score);
            } catch (error) {
                showError("Error showing victory screen: " + error.message);
                // Fallback to regular game over screen if there's an error
                document.getElementById('gameOverlay').style.display = 'flex';
            }
        }
        
        function createVictoryEffects() {
            // Create additional flame elements for celebration
            const victoryFlames = document.querySelector('.victory-flames');
            if (victoryFlames) {
                // Clear existing flames
                victoryFlames.innerHTML = '';
                
                // Add new flames
                for (let i = 0; i < 10; i++) {
                    const flame = document.createElement('div');
                    flame.className = 'victory-flame';
                    flame.style.animationDelay = `${i * 0.2}s`;
                    victoryFlames.appendChild(flame);
                }
            }
        }
        
        function advanceLevel() {
            try {
                // Increase level counter
                gameState.currentLevel++;
                debugLog("Advancing to level: " + gameState.currentLevel);
                
                // Check if all levels are complete
                if (gameState.currentLevel >= levels.length) {
                    showLevelMessage("ALL LEVELS COMPLETED!");
                    setTimeout(() => {
                        endGame(); // This now shows the victory screen
                    }, 2000);
                    return;
                }
                
                // Reset player position
                player.resetPosition();
                
                // Add bonus points
                gameState.updateScore(50);
                
                // Show level announcement
                const levelName = levels[gameState.currentLevel].name;
                showLevelMessage(`Level ${gameState.currentLevel + 1}: ${levelName}`);
                
                debugLog("Advanced to level " + gameState.currentLevel);
            } catch (error) {
                showError("Error advancing level: " + error.message);
            }
        }
        
        function showLevelMessage(text) {
            try {
                const levelMessage = document.createElement('div');
                levelMessage.textContent = text;
                levelMessage.style.position = 'absolute';
                levelMessage.style.top = '50%';
                levelMessage.style.left = '50%';
                levelMessage.style.transform = 'translate(-50%, -50%)';
                levelMessage.style.color = 'white';
                levelMessage.style.fontSize = '6vmin';
                levelMessage.style.fontWeight = 'bold';
                levelMessage.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                levelMessage.style.zIndex = '30';
                levelMessage.style.backgroundColor = 'rgba(0,0,0,0.5)';
                levelMessage.style.padding = '10px 20px';
                levelMessage.style.borderRadius = '10px';
                document.getElementById('gameContainer').appendChild(levelMessage);
                
                setTimeout(() => {
                    if (document.getElementById('gameContainer').contains(levelMessage)) {
                        document.getElementById('gameContainer').removeChild(levelMessage);
                    }
                }, 2000);
            } catch (error) {
                console.error("Error showing level message:", error);
            }
        }
        
        // Game rendering
        function drawBackground(level) {
            if (!level) return;
            
            try {
                // Create gradient background
                const startColor = level.backgroundColor1;
                const endColor = level.backgroundColor2;
                
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add environmental details based on level type
                if (level.name.includes("Forest")) {
                    drawForestBackground();
                } else if (level.name.includes("Mountain")) {
                    drawMountainBackground();
                } else if (level.name.includes("Desert")) {
                    drawDesertBackground();
                } else if (level.name.includes("Cave")) {
                    drawCaveBackground();
                } else if (level.name.includes("Ice")) {
                    drawIceBackground();
                } else if (level.name.includes("Volcanic") || level.name.includes("Flame")) {
                    drawVolcanicBackground();
                } else if (level.name.includes("Ancient")) {
                    drawTempleBackground();
                } else if (level.name.includes("Crystal")) {
                    drawCrystalBackground();
                } else if (level.name.includes("Sky")) {
                    drawSkyBackground();
                }
            } catch (error) {
                console.error("Error drawing background:", error);
                ctx.fillStyle = "#333";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        function drawForestBackground() {
            // Draw trees in background
            const treeCount = Math.floor(canvas.width / 50);
            ctx.fillStyle = 'rgba(34, 139, 34, 0.3)'; // Forest green with transparency
            
            for (let i = 0; i < treeCount; i++) {
                const x = i * 50 + 25;
                const y = canvas.height - 50;
                const height = 30 + (i % 3) * 5;
                
                // Tree
                ctx.beginPath();
                ctx.moveTo(x - 10, y);
                ctx.lineTo(x, y - height);
                ctx.lineTo(x + 10, y);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function drawMountainBackground() {
            // Draw mountains
            ctx.fillStyle = 'rgba(105, 105, 105, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 80);
            
            // First mountain
            ctx.lineTo(canvas.width * 0.3, canvas.height * 0.4);
            ctx.lineTo(canvas.width * 0.5, canvas.height - 80);
            
            // Second mountain
            ctx.lineTo(canvas.width * 0.7, canvas.height * 0.5);
            ctx.lineTo(canvas.width, canvas.height - 80);
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawDesertBackground() {
            // Draw sand dunes
            ctx.fillStyle = 'rgba(210, 180, 140, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 30);
            
            for (let x = 0; x <= canvas.width; x += canvas.width / 6) {
                const height = Math.sin(x / canvas.width * Math.PI) * 40;
                ctx.lineTo(x, canvas.height - 30 - height);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawCaveBackground() {
            // Draw stalactites
            ctx.fillStyle = 'rgba(50, 50, 60, 0.4)';
            
            for (let i = 0; i < 8; i++) {
                const x = i * (canvas.width / 8) + 20;
                const height = 40 + Math.sin(i * 0.8) * 20;
                
                ctx.beginPath();
                ctx.moveTo(x - 10, 0);
                ctx.lineTo(x, height);
                ctx.lineTo(x + 10, 0);
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw stalagmites
            for (let i = 0; i < 5; i++) {
                const x = i * (canvas.width / 5) + 40;
                const height = 30 + Math.cos(i * 0.9) * 15;
                
                ctx.beginPath();
                ctx.moveTo(x - 15, canvas.height);
                ctx.lineTo(x, canvas.height - height);
                ctx.lineTo(x + 15, canvas.height);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function drawIceBackground() {
            // Draw snow mountains
            ctx.fillStyle = 'rgba(220, 220, 240, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 70);
            
            for (let x = 0; x <= canvas.width; x += canvas.width / 8) {
                const height = Math.sin(x / canvas.width * Math.PI * 2) * 50 + 70;
                ctx.lineTo(x, canvas.height - height);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw ice crystals
            ctx.fillStyle = 'rgba(200, 240, 255, 0.2)';
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.6;
                const size = 5 + Math.random() * 15;
                
                ctx.beginPath();
                ctx.moveTo(x, y - size/2);
                ctx.lineTo(x + size/3, y);
                ctx.lineTo(x, y + size/2);
                ctx.lineTo(x - size/3, y);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function drawVolcanicBackground() {
            // Draw lava flows
            const lavaGlow = ctx.createLinearGradient(0, canvas.height - 100, 0, canvas.height);
            lavaGlow.addColorStop(0, 'rgba(255, 69, 0, 0.1)');
            lavaGlow.addColorStop(1, 'rgba(255, 0, 0, 0.3)');
            
            ctx.fillStyle = lavaGlow;
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
            
            // Draw volcano silhouettes
            ctx.fillStyle = 'rgba(50, 20, 20, 0.4)';
            
            // First volcano
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.2, canvas.height);
            ctx.lineTo(canvas.width * 0.4, canvas.height * 0.4);
            ctx.lineTo(canvas.width * 0.6, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Second volcano
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.6, canvas.height);
            ctx.lineTo(canvas.width * 0.8, canvas.height * 0.5);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw some ember particles
            ctx.fillStyle = 'rgba(255, 180, 0, 0.6)';
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height - Math.random() * 150;
                const size = 1 + Math.random() * 3;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawTempleBackground() {
            // Draw distant temple silhouette
            ctx.fillStyle = 'rgba(60, 40, 20, 0.3)';
            
            // Temple base
            ctx.fillRect(canvas.width * 0.3, canvas.height * 0.5, canvas.width * 0.4, canvas.height * 0.2);
            
            // Temple roof/top
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.25, canvas.height * 0.5);
            ctx.lineTo(canvas.width * 0.5, canvas.height * 0.3);
            ctx.lineTo(canvas.width * 0.75, canvas.height * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // Temple columns
            const columnWidth = canvas.width * 0.03;
            const columnSpacing = canvas.width * 0.07;
            const columnBase = canvas.height * 0.5;
            const columnHeight = canvas.height * 0.15;
            
            for (let i = 0; i < 5; i++) {
                const x = canvas.width * 0.32 + i * columnSpacing;
                ctx.fillRect(x, columnBase - columnHeight, columnWidth, columnHeight);
            }
        }
        
        function drawCrystalBackground() {
            // Draw crystal formations
            for (let i = 0; i < 12; i++) {
                const x = i * (canvas.width / 12) + Math.random() * 20;
                const height = 30 + Math.random() * 60;
                const width = 10 + Math.random() * 15;
                
                // Create crystal gradient
                const crystalGradient = ctx.createLinearGradient(x, 0, x + width, 0);
                crystalGradient.addColorStop(0, 'rgba(100, 100, 200, 0.2)');
                crystalGradient.addColorStop(0.5, 'rgba(150, 150, 255, 0.3)');
                crystalGradient.addColorStop(1, 'rgba(100, 100, 200, 0.2)');
                
                ctx.fillStyle = crystalGradient;
                
                // Draw crystal
                ctx.beginPath();
                if (i % 2 === 0) {
                    // Crystal from top
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x + width/2, height);
                    ctx.lineTo(x + width, 0);
                } else {
                    // Crystal from bottom
                    ctx.moveTo(x, canvas.height);
                    ctx.lineTo(x + width/2, canvas.height - height);
                    ctx.lineTo(x + width, canvas.height);
                }
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function drawSkyBackground() {
            // Draw clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            
            for (let i = 0; i < 6; i++) {
                const x = i * (canvas.width / 6) + Math.sin(Date.now() / 5000 + i) * 20;
                const y = 50 + i * 30;
                const width = 80 + Math.sin(i * 0.7) * 20;
                const height = 30 + Math.cos(i * 0.5) * 10;
                
                drawCloud(x, y, width, height);
            }
            
            // Draw distant floating islands
            ctx.fillStyle = 'rgba(100, 180, 100, 0.2)';
            for (let i = 0; i < 4; i++) {
                const x = i * (canvas.width / 4) + 30;
                const y = 100 + i * 40;
                const width = 100 + Math.sin(i) * 30;
                const height = 20 + Math.cos(i) * 5;
                
                // Island base
                ctx.beginPath();
                ctx.ellipse(x, y, width/2, height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Island top (grass)
                ctx.fillStyle = 'rgba(100, 220, 100, 0.2)';
                ctx.beginPath();
                ctx.ellipse(x, y - 2, width/2 - 5, height/2 - 2, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawCloud(x, y, width, height) {
            const numCircles = 3 + Math.floor(width / 40);
            const circleRadius = height * 0.8;
            
            for (let i = 0; i < numCircles; i++) {
                const circleX = x + (i * width/numCircles);
                const circleY = y + Math.sin(i * 0.5) * 5;
                
                ctx.beginPath();
                ctx.arc(circleX, circleY, circleRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawPlatforms(platforms) {
            if (!platforms || !Array.isArray(platforms)) return;
            
            // Calculate scale factor based on canvas size
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 450;
            
            platforms.forEach(platform => {
                // Scale platform dimensions for current canvas size
                const scaledX = platform.x * scaleX;
                const scaledY = platform.y * scaleY;
                const scaledWidth = platform.width * scaleX;
                const scaledHeight = platform.height * scaleY;
                
                // Create platform gradient
                const gradient = ctx.createLinearGradient(
                    scaledX, scaledY, 
                    scaledX, scaledY + scaledHeight
                );
                gradient.addColorStop(0, '#777');
                gradient.addColorStop(0.5, '#555');
                gradient.addColorStop(1, '#333');
                
                // Draw with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 4;
                
                ctx.fillStyle = gradient;
                ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Add highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(scaledX, scaledY, scaledWidth, 2);
            });
        }
        
        function drawObstacles(obstacles) {
            if (!obstacles || !Array.isArray(obstacles)) return;
            
            // Calculate scale factor
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 450;
            
            obstacles.forEach(obstacle => {
                // Scale obstacle dimensions
                const scaledX = obstacle.x * scaleX;
                const scaledY = obstacle.y * scaleY;
                const scaledWidth = obstacle.width * scaleX;
                const scaledHeight = obstacle.height * scaleY;
                
                // Choose color and drawing method based on type
                switch(obstacle.type) {
                    case 'log':
                        ctx.fillStyle = '#8B4513'; // Brown
                        ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                        
                        // Add wood grain
                        ctx.strokeStyle = '#654321';
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            ctx.moveTo(scaledX, scaledY + i * scaledHeight/3);
                            ctx.lineTo(scaledX + scaledWidth, scaledY + i * scaledHeight/3);
                        }
                        ctx.stroke();
                        break;
                        
                    case 'boulder':
                        ctx.fillStyle = '#A9A9A9'; // DarkGray
                        
                        // Draw a more boulder-like shape
                        ctx.beginPath();
                        ctx.moveTo(scaledX, scaledY + scaledHeight);
                        ctx.lineTo(scaledX, scaledY + scaledHeight * 0.3);
                        ctx.lineTo(scaledX + scaledWidth * 0.3, scaledY);
                        ctx.lineTo(scaledX + scaledWidth * 0.7, scaledY);
                        ctx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight * 0.3);
                        ctx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add some texture
                        ctx.strokeStyle = '#808080';
                        ctx.beginPath();
                        ctx.moveTo(scaledX + scaledWidth * 0.2, scaledY + scaledHeight * 0.3);
                        ctx.lineTo(scaledX + scaledWidth * 0.5, scaledY + scaledHeight * 0.5);
                        ctx.moveTo(scaledX + scaledWidth * 0.7, scaledY + scaledHeight * 0.2);
                        ctx.lineTo(scaledX + scaledWidth * 0.5, scaledY + scaledHeight * 0.6);
                        ctx.stroke();
                        break;
                        
                    case 'cactus':
                        ctx.fillStyle = '#2E8B57'; // SeaGreen
                        ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                        
                        // Add cactus arms
                        ctx.fillRect(scaledX - scaledWidth/2, scaledY + scaledHeight/3, scaledWidth/2, scaledHeight/4);
                        ctx.fillRect(scaledX + scaledWidth, scaledY + scaledHeight/2, scaledWidth/2, scaledHeight/4);
                        
                        // Add cactus spines
                        ctx.strokeStyle = '#98FB98';
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            let y = scaledY + (i * scaledHeight/4);
                            ctx.moveTo(scaledX, y);
                            ctx.lineTo(scaledX - 5, y - 2);
                            ctx.moveTo(scaledX + scaledWidth, y);
                            ctx.lineTo(scaledX + scaledWidth + 5, y - 2);
                        }
                        ctx.stroke();
                        break;
                        
                    case 'stalactite':
                        // Draw a stalactite
                        ctx.fillStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(scaledX, scaledY);
                        ctx.lineTo(scaledX + scaledWidth/2, scaledY + scaledHeight);
                        ctx.lineTo(scaledX + scaledWidth, scaledY);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'ice':
                        // Draw an ice obstacle with transparency
                        ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                        ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                        
                        // Add shine effect
                        const iceGradient = ctx.createLinearGradient(
                            scaledX, scaledY, scaledX + scaledWidth, scaledY + scaledHeight
                        );
                        iceGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                        iceGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                        iceGradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
                        
                        ctx.fillStyle = iceGradient;
                        ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                        break;
                        
                    case 'lava':
                        // Draw lava with glow effect
                        const lavaGradient = ctx.createRadialGradient(
                            scaledX + scaledWidth/2, scaledY + scaledHeight/2, 0,
                            scaledX + scaledWidth/2, scaledY + scaledHeight/2, scaledWidth/2
                        );
                        lavaGradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
                        lavaGradient.addColorStop(0.6, 'rgba(255, 50, 0, 0.7)');
                        lavaGradient.addColorStop(1, 'rgba(200, 0, 0, 0.5)');
                        
                        ctx.fillStyle = lavaGradient;
                        
                        // Create wavy top for lava
                        ctx.beginPath();
                        ctx.moveTo(scaledX, scaledY + scaledHeight);
                        
                        const segments = 10;
                        const waveHeight = scaledHeight * 0.2;
                        
                        for (let i = 0; i <= segments; i++) {
                            const x = scaledX + (i * scaledWidth / segments);
                            const y = scaledY + Math.sin(Date.now() / 500 + i) * waveHeight;
                            ctx.lineTo(x, y);
                        }
                        
                        ctx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add glow effect
                        ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        
                        ctx.beginPath();
                        ctx.arc(scaledX + scaledWidth/2, scaledY + scaledHeight/2, scaledWidth/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        break;
                        
                    case 'crystal':
                        // Draw crystal obstacle
                        const crystalGradient = ctx.createLinearGradient(
                            scaledX, scaledY, scaledX + scaledWidth, scaledY + scaledHeight
                        );
                        crystalGradient.addColorStop(0, 'rgba(100, 100, 255, 0.6)');
                        crystalGradient.addColorStop(0.5, 'rgba(150, 150, 255, 0.7)');
                        crystalGradient.addColorStop(1, 'rgba(100, 100, 200, 0.6)');
                        
                        ctx.fillStyle = crystalGradient;
                        
                        // Draw crystal shape
                        ctx.beginPath();
                        ctx.moveTo(scaledX + scaledWidth/2, scaledY);
                        ctx.lineTo(scaledX, scaledY + scaledHeight * 0.3);
                        ctx.lineTo(scaledX + scaledWidth * 0.3, scaledY + scaledHeight);
                        ctx.lineTo(scaledX + scaledWidth * 0.7, scaledY + scaledHeight);
                        ctx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add shine
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.beginPath();
                        ctx.moveTo(scaledX + scaledWidth * 0.3, scaledY + scaledHeight * 0.3);
                        ctx.lineTo(scaledX + scaledWidth * 0.7, scaledY + scaledHeight * 0.7);
                        ctx.stroke();
                        break;
                        
                    case 'cloud':
                        // Draw cloud obstacle
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        drawCloud(scaledX + scaledWidth/2, scaledY + scaledHeight/2, scaledWidth, scaledHeight);
                        break;
                        
                    case 'spike':
                        // Draw spike obstacle
                        ctx.fillStyle = '#8B4513';
                        
                        // Base
                        ctx.fillRect(scaledX, scaledY + scaledHeight * 0.8, scaledWidth, scaledHeight * 0.2);
                        
                        // Spikes
                        ctx.fillStyle = '#A52A2A';
                        const spikeCount = 3;
                        const spikeWidth = scaledWidth / spikeCount;
                        
                        for (let i = 0; i < spikeCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(scaledX + i * spikeWidth, scaledY + scaledHeight * 0.8);
                            ctx.lineTo(scaledX + (i + 0.5) * spikeWidth, scaledY);
                            ctx.lineTo(scaledX + (i + 1) * spikeWidth, scaledY + scaledHeight * 0.8);
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;
                        
                    default:
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                }
            });
        }
        
        function drawCollectibles(collectibles) {
            if (!collectibles || !Array.isArray(collectibles)) return;
            
            // Calculate scale factor
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 450;
            
            collectibles.forEach(collectible => {
                // Scale collectible dimensions
                const scaledX = collectible.x * scaleX;
                const scaledY = collectible.y * scaleY;
                const scaledWidth = collectible.width * scaleX;
                const scaledHeight = collectible.height * scaleY;
                
                const centerX = scaledX + scaledWidth/2;
                const centerY = scaledY + scaledHeight/2;
                
                if (collectible.type === 'flame') {
                    // Flame glow
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                    ctx.shadowBlur = 10;
                    
                    // Flame animation
                    const radius = scaledWidth/2 * (0.8 + Math.sin(Date.now() / 200) * 0.2);
                    
                    // Create flame gradient
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius * 0.3,
                        centerX, centerY, radius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0.6)');
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                } else if (collectible.type === 'powerup') {
                    // Powerup glow
                    ctx.shadowColor = 'rgba(0, 150, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    
                    // Powerup animation
                    const scaleEffect = 0.9 + Math.sin(Date.now() / 200) * 0.1;
                    const displayRadius = scaledWidth/2 * scaleEffect;
                    
                    // Create powerup gradient
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, displayRadius * 0.2,
                        centerX, centerY, displayRadius
                    );
                    gradient.addColorStop(0, 'rgba(200, 255, 255, 1)');
                    gradient.addColorStop(0.6, 'rgba(0, 200, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(0, 50, 200, 0.6)');
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, displayRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Add star effect
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    
                    const time = Date.now() / 1000;
                    const starRotation = time % (Math.PI * 2);
                    
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI / 2) + starRotation;
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(
                            centerX + Math.cos(angle) * displayRadius,
                            centerY + Math.sin(angle) * displayRadius
                        );
                    }
                    ctx.stroke();
                    
                    // Reset shadow and line width
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = 1;
                } else if (collectible.type === 'superflame') {
                    // Super flame glow
                    ctx.shadowColor = 'rgba(255, 220, 0, 0.9)';
                    ctx.shadowBlur = 20;
                    
                    // Multiple flame layers for more impressive effect
                    const baseRadius = scaledWidth/2 * (1 + Math.sin(Date.now() / 200) * 0.2);
                    
                    // Outer flame
                    const outerGradient = ctx.createRadialGradient(
                        centerX, centerY, baseRadius * 0.4,
                        centerX, centerY, baseRadius * 1.2
                    );
                    outerGradient.addColorStop(0, 'rgba(255, 200, 50, 0.8)');
                    outerGradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.6)');
                    outerGradient.addColorStop(1, 'rgba(200, 40, 0, 0.2)');
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, baseRadius * 1.2, 0, Math.PI * 2);
                    ctx.fillStyle = outerGradient;
                    ctx.fill();
                    
                    // Inner flame
                    const innerGradient = ctx.createRadialGradient(
                        centerX, centerY, baseRadius * 0.1,
                        centerX, centerY, baseRadius * 0.8
                    );
                    innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    innerGradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.8)');
                    innerGradient.addColorStop(1, 'rgba(255, 150, 0, 0.6)');
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, baseRadius * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = innerGradient;
                    ctx.fill();
                    
                    // Add pulsing particles
                    const time = Date.now() / 500;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + time;
                        const distance = baseRadius * (0.8 + Math.sin(time * 2 + i) * 0.2);
                        const particleX = centerX + Math.cos(angle) * distance;
                        const particleY = centerY + Math.sin(angle) * distance;
                        const particleSize = 2 + Math.sin(time * 3 + i * 2) * 1;
                        
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
                        ctx.fill();
                    }
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        function drawUI() {
            // Get current level
            const level = levels[gameState.currentLevel];
            if (!level) return;
            
            // Draw score and lives
            ctx.fillStyle = 'white';
            ctx.font = '4vmin Arial';
            ctx.fillText(`Score: ${gameState.score}`, 20, 30);
            ctx.fillText(`Lives: ${gameState.lives}`, 20, 60);
            
            // Draw level name and flames
            ctx.textAlign = 'center';
            ctx.fillText(`Level ${gameState.currentLevel + 1}: ${level.name}`, canvas.width/2, 30);
            ctx.fillText(`Flames: ${level.collectibles.length}`, canvas.width/2, 60);
            ctx.textAlign = 'left';
            
            // Draw flame meter
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            const meterWidth = canvas.width / 4;
            ctx.fillRect(canvas.width - meterWidth - 20, 20, meterWidth, 15);
            
            const flameWidth = (player.flameSize / 100) * meterWidth;
            ctx.fillStyle = `rgb(
                255, 
                ${Math.min(255, 100 + player.flameSize)}, 
                ${Math.min(255, 50 + player.flameSize / 2)}
            )`;
            ctx.fillRect(canvas.width - meterWidth - 20, 20, flameWidth, 15);
        }
        
        // Game loop
        function gameLoop() {
            if (!gameState.gameActive) {
                gameState.gameActive = true; // Set active flag
                debugLog("Game loop started");
                
                // Force check platform collision on first frame
                player.checkPlatformCollisions(levels[gameState.currentLevel].platforms);
            }
            
            try {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Get current level
                const currentLevel = levels[gameState.currentLevel];
                if (!currentLevel) {
                    throw new Error("Level not found: " + gameState.currentLevel);
                }
                
                // Draw background
                drawBackground(currentLevel);
                
                // Draw game elements
                drawPlatforms(currentLevel.platforms);
                drawObstacles(currentLevel.obstacles);
                drawCollectibles(currentLevel.collectibles);
                
                // Check platform collisions and update player
                const onGround = player.checkPlatformCollisions(currentLevel.platforms);
                debugLog(`Player state: x=${Math.round(player.x)}, y=${Math.round(player.y)}, onGround=${onGround}, flame=${Math.round(player.flameSize)}`);
                
                // Update player
                player.update();
                
                // Check collisions
                player.checkObstacleCollisions(currentLevel.obstacles);
                
                if (player.checkCollectibleCollisions(currentLevel.collectibles)) {
                    // Check if level is complete (no more collectibles)
                    if (currentLevel.collectibles.length === 0) {
                        advanceLevel();
                    }
                }
                
                // Draw player
                player.draw(ctx);
                
                // Draw UI
                drawUI();
                
                // Continue loop
                gameLoopId = requestAnimationFrame(gameLoop);
            } catch (error) {
                showError("Game loop error: " + error.message);
                console.error("Game loop error:", error);
                
                // Try to restart the game loop after an error
                if (gameState.gameActive) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }
        }
        
        // High scores functions
        function displayHighScores() {
            try {
                const highScoresList = document.getElementById('highScoresList');
                
                if (highScoresList) {
                    if (gameState.highScores.length > 0) {
                        highScoresList.innerHTML = gameState.highScores.map((score, index) => 
                            `<div>${index + 1}. ${score.score} - Level ${score.level}</div>`
                        ).join('');
                    } else {
                        highScoresList.innerHTML = "<div>No high scores yet!</div>";
                    }
                }
            } catch (error) {
                console.error("Error displaying high scores:", error);
            }
        }
        
        function loadHighScores() {
            try {
                const savedScores = localStorage.getItem('flameWalkerScores');
                
                if (savedScores) {
                    gameState.highScores = JSON.parse(savedScores);
                }
                
                displayHighScores();
            } catch (error) {
                showError("Error loading high scores: " + error.message);
            }
        }
        
        // Initialize when DOM is ready
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
